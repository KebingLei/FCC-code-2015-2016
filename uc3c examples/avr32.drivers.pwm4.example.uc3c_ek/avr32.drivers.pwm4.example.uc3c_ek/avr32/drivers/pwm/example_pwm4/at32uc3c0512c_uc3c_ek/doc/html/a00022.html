<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PWM4 Example for uc3c_ek: flashc.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>flashc.c File Reference</h1>
<p>FLASHC driver for AVR32 UC3.  
<a href="#_details">More...</a></p>
<code>#include &lt;avr32/io.h&gt;</code><br/>
<code>#include &lt;stddef.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="a00021_source.html">compiler.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="a00022_source.html">flashc.h</a>&quot;</code><br/>
<div class="dynheader">
Include dependency graph for flashc.c:</div>
<div class="dynsection">
</div>
<div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dynsection">
</div>

<p><a href="a00022_source.html">Go to the source code of this file.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00010.html">u_avr32_flashc_fcmd_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">union &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00011.html">u_avr32_flashc_fcr_t</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">FLASHC Protection Mechanisms</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp3b373839fa1dd0f88b64f74689269dfd"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a245cc33e09bc45b78d4fdc189ba6fd85">flashc_activate_security_bit</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Activates the Security bit.  <a href="#a245cc33e09bc45b78d4fdc189ba6fd85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a83ed88a41076163bd29ca80d30cb094f">flashc_get_bootloader_protected_size</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the bootloader protected size.  <a href="#a83ed88a41076163bd29ca80d30cb094f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a64607cf8bb7de7e226973c7d9a10170d">flashc_is_external_privileged_fetch_locked</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether external privileged fetch is locked.  <a href="#a64607cf8bb7de7e226973c7d9a10170d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#afa30fe317124244e8c5a7fcc7a0ba44b">flashc_is_page_region_locked</a> (int page_number)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the region of a page is locked.  <a href="#afa30fe317124244e8c5a7fcc7a0ba44b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#ae6e9e45c046406a645ffac5e3fd62d40">flashc_is_region_locked</a> (unsigned int region)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether a region is locked.  <a href="#ae6e9e45c046406a645ffac5e3fd62d40"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a03df73f0be08f7bc503f3c336b1abdc1">flashc_is_security_bit_active</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the Security bit is active.  <a href="#a03df73f0be08f7bc503f3c336b1abdc1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a7c05cca97169ee6888828c40243c0191">flashc_lock_all_regions</a> (Bool lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks or unlocks all regions.  <a href="#a7c05cca97169ee6888828c40243c0191"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a5b5725c807435b40115f4577a79b88b2">flashc_lock_external_privileged_fetch</a> (Bool lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks or unlocks external privileged fetch.  <a href="#a5b5725c807435b40115f4577a79b88b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#aa79c8c0023a4813a08cff039ccd003ab">flashc_lock_page_region</a> (int page_number, Bool lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks or unlocks the region of a page.  <a href="#aa79c8c0023a4813a08cff039ccd003ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a026f45da4ae8afea4d40066d3523ee3b">flashc_lock_region</a> (unsigned int region, Bool lock)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Locks or unlocks a region.  <a href="#a026f45da4ae8afea4d40066d3523ee3b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a076a1b22c9f3e6dad1739f0398f89b37">flashc_set_bootloader_protected_size</a> (unsigned int bootprot_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the bootloader protected size.  <a href="#a076a1b22c9f3e6dad1739f0398f89b37"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to Flash Pages</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp3ec99465093057fc01025a8d8167b157"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#affafe9cb74731d817b721d2a52093412">flashc_clear_page_buffer</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the page buffer.  <a href="#affafe9cb74731d817b721d2a52093412"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a230f4c4dcf517606a540dfa1df3efa91">flashc_erase_all_pages</a> (Bool check)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases all pages within the flash array.  <a href="#a230f4c4dcf517606a540dfa1df3efa91"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a8de3bbd50094f548ca293f07b136cc6d">flashc_erase_page</a> (int page_number, Bool check)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases a page.  <a href="#a8de3bbd50094f548ca293f07b136cc6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a2ef66c5ffa0974223c44e151a8719b6d">flashc_erase_user_page</a> (Bool check)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases the User page.  <a href="#a2ef66c5ffa0974223c44e151a8719b6d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#acdea4bfb0cb1066fba239a9302196ee5">flashc_is_page_erased</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the page to which the last Quick Page Read or Quick Page Read User Page command was applied was erased.  <a href="#acdea4bfb0cb1066fba239a9302196ee5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">volatile void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#ab257e261b58cabbd30f176287882886e">flashc_memcpy</a> (volatile void *dst, const void *src, size_t nbytes, Bool erase)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the source pointed to by <em>src</em>.  <a href="#ab257e261b58cabbd30f176287882886e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">volatile void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a1e3ac5049d1eed492678764f8d1efc4b">flashc_memset16</a> (volatile void *dst, U16 src, size_t nbytes, Bool erase)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the repeated <em>src</em> big-endian source half-word.  <a href="#a1e3ac5049d1eed492678764f8d1efc4b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">volatile void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#af51102eac590a354c08f3b4311745674">flashc_memset32</a> (volatile void *dst, U32 src, size_t nbytes, Bool erase)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the repeated <em>src</em> big-endian source word.  <a href="#af51102eac590a354c08f3b4311745674"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">volatile void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#ad232684f65e596ffd85a63e0c1a5c41d">flashc_memset64</a> (volatile void *dst, U64 src, size_t nbytes, Bool erase)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the repeated <em>src</em> big-endian source double-word.  <a href="#ad232684f65e596ffd85a63e0c1a5c41d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">volatile void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#acc5c426d84ce1ef1d2e898e827b23207">flashc_memset8</a> (volatile void *dst, U8 src, size_t nbytes, Bool erase)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the repeated <em>src</em> source byte.  <a href="#acc5c426d84ce1ef1d2e898e827b23207"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#acd50527aacf1d9ae11608fcc49a4fdcf">flashc_quick_page_read</a> (int page_number)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Applies the Quick Page Read command to a page.  <a href="#acd50527aacf1d9ae11608fcc49a4fdcf"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a4cdef3bd6e4b7da53e4b7b7dc1adcd2f">flashc_quick_user_page_read</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Issues a Quick Page Read User Page command to the FLASHC.  <a href="#a4cdef3bd6e4b7da53e4b7b7dc1adcd2f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#aa10438433246139bee71da6db2bb5bd5">flashc_write_page</a> (int page_number)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a page from the page buffer.  <a href="#aa10438433246139bee71da6db2bb5bd5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#ad04374b721dca9c534d7cd041ae24712">flashc_write_user_page</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes the User page from the page buffer.  <a href="#ad04374b721dca9c534d7cd041ae24712"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">FLASHC Control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpc6704de05d9cd41a41d959dd8e3d74fc"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#ada1616072a05bb5d85e4c64af8826757">flashc_enable_lock_error_int</a> (Bool enable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the Lock Error interrupt.  <a href="#ada1616072a05bb5d85e4c64af8826757"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a1ac3cdbea1169c7f292db30f7c7a48bc">flashc_enable_prog_error_int</a> (Bool enable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the Programming Error interrupt.  <a href="#a1ac3cdbea1169c7f292db30f7c7a48bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a11ae526262d08d12815ec74f503c63c0">flashc_enable_ready_int</a> (Bool enable)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enables or disables the Flash Ready interrupt.  <a href="#a11ae526262d08d12815ec74f503c63c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a52784dbdd246c6c320e5041026d4da08">flashc_get_wait_state</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of wait states of flash read accesses.  <a href="#a52784dbdd246c6c320e5041026d4da08"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#ad9a950413a6b9d64a832b82ebaa2c38d">flashc_is_lock_error_int_enabled</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the Lock Error interrupt is enabled.  <a href="#ad9a950413a6b9d64a832b82ebaa2c38d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#aec6b3818f1a6a0d4bf69838c2743de85">flashc_is_prog_error_int_enabled</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the Programming Error interrupt is enabled.  <a href="#aec6b3818f1a6a0d4bf69838c2743de85"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a517223d37600d347adc24fed238ebaf7">flashc_is_ready_int_enabled</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the Flash Ready interrupt is enabled.  <a href="#a517223d37600d347adc24fed238ebaf7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a5dda977da7d7381b125b2fa25ef9ae90">flashc_set_bus_freq</a> (unsigned int cpu_f_hz)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Depending on the CPU frequency, set the wait states of flash read accesses.  <a href="#a5dda977da7d7381b125b2fa25ef9ae90"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a2835c7ef58f410290ad530d34d7e8133">flashc_set_wait_state</a> (unsigned int wait_state)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the number of wait states of flash read accesses.  <a href="#a2835c7ef58f410290ad530d34d7e8133"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">FLASHC Global Commands</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpc04b319491bf30f4fa418509ee80c6e1"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a56f654a36c20b651412bbb689b8a4b2c">flashc_erase_all</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Issues an Erase All command to the FLASHC.  <a href="#a56f654a36c20b651412bbb689b8a4b2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#aac955da1ba0b0833d17d3068c34222ec">flashc_no_operation</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Issues a No Operation command to the FLASHC.  <a href="#aac955da1ba0b0833d17d3068c34222ec"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to General-Purpose Fuses</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp710f00c22a3b43e05909292e0672388d"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#acf3096dc9ecea92533c4688d7f90a0ef">flashc_erase_all_gp_fuses</a> (Bool check)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases all general-purpose fuses.  <a href="#acf3096dc9ecea92533c4688d7f90a0ef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a3d3494ba9bfe90893f65d2d3d90ab088">flashc_erase_gp_fuse_bit</a> (unsigned int gp_fuse_bit, Bool check)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases a general-purpose fuse bit.  <a href="#a3d3494ba9bfe90893f65d2d3d90ab088"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a5e1c12e72c0d141bc13fed9fe6a7dd19">flashc_erase_gp_fuse_bitfield</a> (unsigned int pos, unsigned int width, Bool check)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases a general-purpose fuse bit-field.  <a href="#a5e1c12e72c0d141bc13fed9fe6a7dd19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a293468b5d263ffe7f9a2595c900a9293">flashc_erase_gp_fuse_byte</a> (unsigned int gp_fuse_byte, Bool check)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases a general-purpose fuse byte.  <a href="#a293468b5d263ffe7f9a2595c900a9293"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a08124caa02942b5fa1d370a81a84dfb5">flashc_read_all_gp_fuses</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads all general-purpose fuses.  <a href="#a08124caa02942b5fa1d370a81a84dfb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#ae6203d2e69ff15d59366c28bf8e26a7e">flashc_read_gp_fuse_bit</a> (unsigned int gp_fuse_bit)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a general-purpose fuse bit.  <a href="#ae6203d2e69ff15d59366c28bf8e26a7e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U64&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a0a0ce2691a31e0d529ec1143d61c4a86">flashc_read_gp_fuse_bitfield</a> (unsigned int pos, unsigned int width)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a general-purpose fuse bit-field.  <a href="#a0a0ce2691a31e0d529ec1143d61c4a86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">U8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a1ad2aab294e528795bbd835539b0b14e">flashc_read_gp_fuse_byte</a> (unsigned int gp_fuse_byte)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a general-purpose fuse byte.  <a href="#a1ad2aab294e528795bbd835539b0b14e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#ac00d0edaa152b6d107c5cdb9350ba97d">flashc_set_all_gp_fuses</a> (U64 value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets all general-purpose fuses with the appropriate erase and write operations.  <a href="#ac00d0edaa152b6d107c5cdb9350ba97d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a5c5442a988c608baea0d1c0b841badca">flashc_set_gp_fuse_bit</a> (unsigned int gp_fuse_bit, Bool value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a general-purpose fuse bit with the appropriate erase and write operations.  <a href="#a5c5442a988c608baea0d1c0b841badca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a8969b973563adb568121db44768a2246">flashc_set_gp_fuse_bitfield</a> (unsigned int pos, unsigned int width, U64 value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a general-purpose fuse bit-field with the appropriate erase and write operations.  <a href="#a8969b973563adb568121db44768a2246"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#acda1125f62193f69c24c0e4975e95b4d">flashc_set_gp_fuse_byte</a> (unsigned int gp_fuse_byte, U8 value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets a general-purpose fuse byte with the appropriate erase and write operations.  <a href="#acda1125f62193f69c24c0e4975e95b4d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a408609845a9b3de37bf9307076d851d6">flashc_write_all_gp_fuses</a> (U64 value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes all general-purpose fuses.  <a href="#a408609845a9b3de37bf9307076d851d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a52f9456a7effcc28290c3139f7d54bfc">flashc_write_gp_fuse_bit</a> (unsigned int gp_fuse_bit, Bool value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a general-purpose fuse bit.  <a href="#a52f9456a7effcc28290c3139f7d54bfc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a018e2f6ca164ef9b9d680de53cf08739">flashc_write_gp_fuse_bitfield</a> (unsigned int pos, unsigned int width, U64 value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a general-purpose fuse bit-field.  <a href="#a018e2f6ca164ef9b9d680de53cf08739"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a7670e69d41fe6a985ad898be25044caf">flashc_write_gp_fuse_byte</a> (unsigned int gp_fuse_byte, U8 value)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a general-purpose fuse byte.  <a href="#a7670e69d41fe6a985ad898be25044caf"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">FLASHC Command Control</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrpde34d62750d609bb43444cb9d9ec66d9"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a36519235197ff4d6ab7f5adcb3fce6c1">flashc_get_command</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the last issued FLASHC command.  <a href="#a36519235197ff4d6ab7f5adcb3fce6c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#adb51a37e3153c24e5dd6cf06daac0e21">flashc_get_page_number</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the current FLASHC page number.  <a href="#adb51a37e3153c24e5dd6cf06daac0e21"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a8045c427c32cf3617e861067d76c9c11">flashc_issue_command</a> (unsigned int command, int page_number)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Issues a FLASHC command.  <a href="#a8045c427c32cf3617e861067d76c9c11"></a><br/></td></tr>
<tr><td colspan="2"><div class="groupHeader">Flash Properties</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p><a class="anchor" id="amgrp29f8d9f5119c1bdb926269f0765e72b5"></a> </p>
</div></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a8071c315b02d038c49fa0bf89a40ba1b">flashc_get_flash_size</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the size of the whole flash array.  <a href="#a8071c315b02d038c49fa0bf89a40ba1b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#aafad0dcf645cc65acb5bc879558dac23">flashc_get_page_count</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the total number of pages in the flash array.  <a href="#aafad0dcf645cc65acb5bc879558dac23"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a8910bcde3235e2af0770fbd2412b05bc">flashc_get_page_count_per_region</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of pages in each flash region.  <a href="#a8910bcde3235e2af0770fbd2412b05bc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#ac5871dc98c8812b0413efd6456508999">flashc_get_page_region</a> (int page_number)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the region number of a page.  <a href="#ac5871dc98c8812b0413efd6456508999"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a43b14107d406ea9025f8947490c9ddcd">flashc_get_region_first_page_number</a> (unsigned int region)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the number of the first page of a region.  <a href="#a43b14107d406ea9025f8947490c9ddcd"></a><br/></td></tr>
<tr><td colspan="2"><h2>FLASHC Status</h2></td></tr>
<tr><td colspan="2"><p><a class="anchor" id="amgrpa80e7cbd6cc7ef503434e48b0640bbce"></a> </p>
<br/><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> = 0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sticky error status of the FLASHC.  <a href="#af22dcfb635e7fa6bf926dc810e40d6be"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void(*volatile&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a180c9966f5242650e00e4a231956acec">flashc_wait_until_ready</a> )(void) = flashc_default_wait_until_ready</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pointer to the function used by the driver when it needs to wait until the FLASHC is ready to run a new command.  <a href="#a180c9966f5242650e00e4a231956acec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#aca88002d64a494ca5b796b592834369d">flashc_default_wait_until_ready</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits actively until the FLASHC is ready to run a new command.  <a href="#aca88002d64a494ca5b796b592834369d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#ae7d38c60001d5d8d00363a6cb07f89f0">flashc_get_error_status</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the error status of the FLASHC.  <a href="#ae7d38c60001d5d8d00363a6cb07f89f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether a Lock Error has occurred during the last function called that issued one or more FLASHC commands.  <a href="#aa5e4eb7ae688be5d59fca4bb6a326447"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether a Programming Error has occurred during the last function called that issued one or more FLASHC commands.  <a href="#a2556a29213a1be8df40df2f8868077bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="a00022.html#ac47ea338258641e6fe9361885a116c39">flashc_is_ready</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tells whether the FLASHC is ready to run a new command.  <a href="#ac47ea338258641e6fe9361885a116c39"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>FLASHC driver for AVR32 UC3. </p>
<p>AVR32 Flash Controller driver module.</p>
<ul>
<li>Compiler: IAR EWAVR32 and GNU GCC for AVR32</li>
<li>Supported devices: All AVR32 devices with a FLASHC module can be used.</li>
<li>AppNote:</li>
</ul>
<dl class="author"><dt><b>Author:</b></dt><dd>Atmel Corporation: <a href="http://www.atmel.com">http://www.atmel.com</a> <br/>
 Support and FAQ: <a href="http://support.atmel.no/">http://support.atmel.no/</a> </dd></dl>

<p>Definition in file <a class="el" href="a00022_source.html">flashc.c</a>.</p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a245cc33e09bc45b78d4fdc189ba6fd85"></a><!-- doxytag: member="flashc.c::flashc_activate_security_bit" ref="a245cc33e09bc45b78d4fdc189ba6fd85" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_activate_security_bit </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Activates the Security bit. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00346">346</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00347"></a>00347 {
<a name="l00348"></a>00348   <a class="code" href="a00022.html#a8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_SSB, -1);
<a name="l00349"></a>00349 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="affafe9cb74731d817b721d2a52093412"></a><!-- doxytag: member="flashc.c::flashc_clear_page_buffer" ref="affafe9cb74731d817b721d2a52093412" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_clear_page_buffer </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the page buffer. </p>
<p>This command resets all bits in the page buffer to one. Write accesses to the page buffer can only change page buffer bits from one to zero.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The page buffer is not automatically reset after a page write.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00621">621</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00886">flashc_memcpy()</a>, and <a class="el" href="a00022_source.html#l00713">flashc_memset64()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00622"></a>00622 {
<a name="l00623"></a>00623   <a class="code" href="a00022.html#a8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_CPB, -1);
<a name="l00624"></a>00624 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="aca88002d64a494ca5b796b592834369d"></a><!-- doxytag: member="flashc.c::flashc_default_wait_until_ready" ref="aca88002d64a494ca5b796b592834369d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_default_wait_until_ready </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits actively until the FLASHC is ready to run a new command. </p>
<p>This is the default function assigned to <a class="el" href="a00023.html#a180c9966f5242650e00e4a231956acec">flashc_wait_until_ready</a>. </p>

<p>Definition at line <a class="el" href="a00022_source.html#l00233">233</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00227">flashc_is_ready()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00234"></a>00234 {
<a name="l00235"></a>00235   <span class="keywordflow">while</span> (!<a class="code" href="a00022.html#ac47ea338258641e6fe9361885a116c39" title="Tells whether the FLASHC is ready to run a new command.">flashc_is_ready</a>());
<a name="l00236"></a>00236 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="ada1616072a05bb5d85e4c64af8826757"></a><!-- doxytag: member="flashc.c::flashc_enable_lock_error_int" ref="ada1616072a05bb5d85e4c64af8826757" args="(Bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_enable_lock_error_int </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>enable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the Lock Error interrupt. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>Whether to enable the Lock Error interrupt: <code>TRUE</code> or <code>FALSE</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00197">197</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00021_source.html#l00360">FALSE</a>, <a class="el" href="a00022_source.html#l00060">u_avr32_flashc_fcr_t::fcr</a>, and <a class="el" href="a00022_source.html#l00061">u_avr32_flashc_fcr_t::FCR</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00198"></a>00198 {
<a name="l00199"></a>00199   <a class="code" href="a00011.html">u_avr32_flashc_fcr_t</a> u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
<a name="l00200"></a>00200   u_avr32_flashc_fcr.<a class="code" href="a00011.html#aa8f3a48553db579f2272c10a5ad2c710">FCR</a>.locke = (enable != <a class="code" href="a00021.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l00201"></a>00201   AVR32_FLASHC.fcr = u_avr32_flashc_fcr.<a class="code" href="a00011.html#a4931f45cdf8856a36fd6670033cfbe99">fcr</a>;
<a name="l00202"></a>00202 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a1ac3cdbea1169c7f292db30f7c7a48bc"></a><!-- doxytag: member="flashc.c::flashc_enable_prog_error_int" ref="a1ac3cdbea1169c7f292db30f7c7a48bc" args="(Bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_enable_prog_error_int </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>enable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the Programming Error interrupt. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>Whether to enable the Programming Error interrupt: <code>TRUE</code> or <code>FALSE</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00211">211</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00021_source.html#l00360">FALSE</a>, <a class="el" href="a00022_source.html#l00060">u_avr32_flashc_fcr_t::fcr</a>, and <a class="el" href="a00022_source.html#l00061">u_avr32_flashc_fcr_t::FCR</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00212"></a>00212 {
<a name="l00213"></a>00213   <a class="code" href="a00011.html">u_avr32_flashc_fcr_t</a> u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
<a name="l00214"></a>00214   u_avr32_flashc_fcr.<a class="code" href="a00011.html#aa8f3a48553db579f2272c10a5ad2c710">FCR</a>.proge = (enable != <a class="code" href="a00021.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l00215"></a>00215   AVR32_FLASHC.fcr = u_avr32_flashc_fcr.<a class="code" href="a00011.html#a4931f45cdf8856a36fd6670033cfbe99">fcr</a>;
<a name="l00216"></a>00216 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a11ae526262d08d12815ec74f503c63c0"></a><!-- doxytag: member="flashc.c::flashc_enable_ready_int" ref="a11ae526262d08d12815ec74f503c63c0" args="(Bool enable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_enable_ready_int </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>enable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enables or disables the Flash Ready interrupt. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>enable</em>&nbsp;</td><td>Whether to enable the Flash Ready interrupt: <code>TRUE</code> or <code>FALSE</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00183">183</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00021_source.html#l00360">FALSE</a>, <a class="el" href="a00022_source.html#l00060">u_avr32_flashc_fcr_t::fcr</a>, and <a class="el" href="a00022_source.html#l00061">u_avr32_flashc_fcr_t::FCR</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00184"></a>00184 {
<a name="l00185"></a>00185   <a class="code" href="a00011.html">u_avr32_flashc_fcr_t</a> u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
<a name="l00186"></a>00186   u_avr32_flashc_fcr.<a class="code" href="a00011.html#aa8f3a48553db579f2272c10a5ad2c710">FCR</a>.frdy = (enable != <a class="code" href="a00021.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l00187"></a>00187   AVR32_FLASHC.fcr = u_avr32_flashc_fcr.<a class="code" href="a00011.html#a4931f45cdf8856a36fd6670033cfbe99">fcr</a>;
<a name="l00188"></a>00188 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a56f654a36c20b651412bbb689b8a4b2c"></a><!-- doxytag: member="flashc.c::flashc_erase_all" ref="a56f654a36c20b651412bbb689b8a4b2c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_erase_all </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Issues an Erase All command to the FLASHC. </p>
<p>This command erases all bits in the flash array, the general-purpose fuse bits and the Security bit. The User page is not erased.</p>
<p>This command also ensures that all volatile memories, such as register file and RAMs, are erased before the Security bit is erased, i.e. deactivated.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if at least one region is locked or the bootloader protection is active.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
An erase operation can only set bits. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00326">326</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00327"></a>00327 {
<a name="l00328"></a>00328   <a class="code" href="a00022.html#a8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_EA, -1);
<a name="l00329"></a>00329 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="acf3096dc9ecea92533c4688d7f90a0ef"></a><!-- doxytag: member="flashc.c::flashc_erase_all_gp_fuses" ref="acf3096dc9ecea92533c4688d7f90a0ef" args="(Bool check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_erase_all_gp_fuses </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>check</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases all general-purpose fuses. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Whether to check erase: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the erase succeeded or always <code>TRUE</code> if erase check was not requested.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
An erase operation can only set bits.</dd>
<dd>
The actual number of general-purpose fuse bits implemented by hardware is given by <code>AVR32_FLASHC_GPF_NUM</code>. The other bits among the 64 are fixed at 1 by hardware. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00501">501</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>, <a class="el" href="a00022_source.html#l00452">flashc_read_all_gp_fuses()</a>, and <a class="el" href="a00021_source.html#l00361">TRUE</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00481">flashc_erase_gp_fuse_byte()</a>, and <a class="el" href="a00022_source.html#l00593">flashc_set_all_gp_fuses()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00502"></a>00502 {
<a name="l00503"></a>00503   <a class="code" href="a00022.html#a8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_EAGPF, -1);
<a name="l00504"></a>00504   <span class="keywordflow">return</span> (check) ? (<a class="code" href="a00022.html#a08124caa02942b5fa1d370a81a84dfb5" title="Reads all general-purpose fuses.">flashc_read_all_gp_fuses</a>() == 0xFFFFFFFFFFFFFFFFULL) : <a class="code" href="a00021.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00505"></a>00505 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a230f4c4dcf517606a540dfa1df3efa91"></a><!-- doxytag: member="flashc.c::flashc_erase_all_pages" ref="a230f4c4dcf517606a540dfa1df3efa91" args="(Bool check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_erase_all_pages </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>check</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases all pages within the flash array. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Whether to check erase: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the erase succeeded or always <code>TRUE</code> if erase check was not requested.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if at least one region is locked or the bootloader protection is active.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
An erase operation can only set bits. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00654">654</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00640">flashc_erase_page()</a>, <a class="el" href="a00022_source.html#l00263">flashc_error_status</a>, <a class="el" href="a00022_source.html#l00117">flashc_get_page_count()</a>, and <a class="el" href="a00021_source.html#l00361">TRUE</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00655"></a>00655 {
<a name="l00656"></a>00656   Bool all_pages_erased = <a class="code" href="a00021.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00657"></a>00657   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = 0;
<a name="l00658"></a>00658   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> page_number = <a class="code" href="a00022.html#aafad0dcf645cc65acb5bc879558dac23" title="Gets the total number of pages in the flash array.">flashc_get_page_count</a>();
<a name="l00659"></a>00659   <span class="keywordflow">while</span> (page_number)
<a name="l00660"></a>00660   {
<a name="l00661"></a>00661     all_pages_erased &amp;= <a class="code" href="a00022.html#a8de3bbd50094f548ca293f07b136cc6d" title="Erases a page.">flashc_erase_page</a>(--page_number, check);
<a name="l00662"></a>00662     error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00663"></a>00663   }
<a name="l00664"></a>00664   <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a> = error_status;
<a name="l00665"></a>00665   <span class="keywordflow">return</span> all_pages_erased;
<a name="l00666"></a>00666 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a3d3494ba9bfe90893f65d2d3d90ab088"></a><!-- doxytag: member="flashc.c::flashc_erase_gp_fuse_bit" ref="a3d3494ba9bfe90893f65d2d3d90ab088" args="(unsigned int gp_fuse_bit, Bool check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_erase_gp_fuse_bit </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gp_fuse_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>check</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases a general-purpose fuse bit. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gp_fuse_bit</em>&nbsp;</td><td>The general-purpose fuse bit: <code>0</code> to <code>63</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Whether to check erase: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the erase succeeded or always <code>TRUE</code> if erase check was not requested.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active and the command is applied to BOOTPROT or EPFL fuses.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
An erase operation can only set bits.</dd>
<dd>
The actual number of general-purpose fuse bits implemented by hardware is given by <code>AVR32_FLASHC_GPF_NUM</code>. The other bits among the 64 are fixed at 1 by hardware. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00458">458</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>, <a class="el" href="a00022_source.html#l00434">flashc_read_gp_fuse_bit()</a>, and <a class="el" href="a00021_source.html#l00361">TRUE</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00465">flashc_erase_gp_fuse_bitfield()</a>, and <a class="el" href="a00022_source.html#l00549">flashc_set_gp_fuse_bit()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00459"></a>00459 {
<a name="l00460"></a>00460   <a class="code" href="a00022.html#a8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_EGPB, gp_fuse_bit &amp; 0x3F);
<a name="l00461"></a>00461   <span class="keywordflow">return</span> (check) ? <a class="code" href="a00022.html#ae6203d2e69ff15d59366c28bf8e26a7e" title="Reads a general-purpose fuse bit.">flashc_read_gp_fuse_bit</a>(gp_fuse_bit) : <a class="code" href="a00021.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00462"></a>00462 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a5e1c12e72c0d141bc13fed9fe6a7dd19"></a><!-- doxytag: member="flashc.c::flashc_erase_gp_fuse_bitfield" ref="a5e1c12e72c0d141bc13fed9fe6a7dd19" args="(unsigned int pos, unsigned int width, Bool check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_erase_gp_fuse_bitfield </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>check</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases a general-purpose fuse bit-field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The bit-position of the general-purpose fuse bit-field: <code>0</code> to <code>63</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The bit-width of the general-purpose fuse bit-field: <code>0</code> to <code>64</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Whether to check erase: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the erase succeeded or always <code>TRUE</code> if erase check was not requested.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active and the command is applied to BOOTPROT or EPFL fuses.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
An erase operation can only set bits.</dd>
<dd>
The actual number of general-purpose fuse bits implemented by hardware is given by <code>AVR32_FLASHC_GPF_NUM</code>. The other bits among the 64 are fixed at 1 by hardware. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00465">465</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00021_source.html#l00360">FALSE</a>, <a class="el" href="a00022_source.html#l00458">flashc_erase_gp_fuse_bit()</a>, <a class="el" href="a00022_source.html#l00263">flashc_error_status</a>, <a class="el" href="a00022_source.html#l00440">flashc_read_gp_fuse_bitfield()</a>, and <a class="el" href="a00021_source.html#l00361">TRUE</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00466"></a>00466 {
<a name="l00467"></a>00467   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = 0;
<a name="l00468"></a>00468   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gp_fuse_bit;
<a name="l00469"></a>00469   pos &amp;= 0x3F;
<a name="l00470"></a>00470   width = min(width, 64);
<a name="l00471"></a>00471   <span class="keywordflow">for</span> (gp_fuse_bit = pos; gp_fuse_bit &lt; pos + width; gp_fuse_bit++)
<a name="l00472"></a>00472   {
<a name="l00473"></a>00473     <a class="code" href="a00022.html#a3d3494ba9bfe90893f65d2d3d90ab088" title="Erases a general-purpose fuse bit.">flashc_erase_gp_fuse_bit</a>(gp_fuse_bit, <a class="code" href="a00021.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l00474"></a>00474     error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00475"></a>00475   }
<a name="l00476"></a>00476   <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a> = error_status;
<a name="l00477"></a>00477   <span class="keywordflow">return</span> (check) ? (<a class="code" href="a00022.html#a0a0ce2691a31e0d529ec1143d61c4a86" title="Reads a general-purpose fuse bit-field.">flashc_read_gp_fuse_bitfield</a>(pos, width) == (1ULL &lt;&lt; width) - 1) : <a class="code" href="a00021.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00478"></a>00478 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a293468b5d263ffe7f9a2595c900a9293"></a><!-- doxytag: member="flashc.c::flashc_erase_gp_fuse_byte" ref="a293468b5d263ffe7f9a2595c900a9293" args="(unsigned int gp_fuse_byte, Bool check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_erase_gp_fuse_byte </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gp_fuse_byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>check</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases a general-purpose fuse byte. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gp_fuse_byte</em>&nbsp;</td><td>The general-purpose fuse byte: <code>0</code> to <code>7</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Whether to check erase: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the erase succeeded or always <code>TRUE</code> if erase check was not requested.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
An erase operation can only set bits.</dd>
<dd>
The actual number of general-purpose fuse bits implemented by hardware is given by <code>AVR32_FLASHC_GPF_NUM</code>. The other bits among the 64 are fixed at 1 by hardware. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00481">481</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00021_source.html#l00360">FALSE</a>, <a class="el" href="a00022_source.html#l00501">flashc_erase_all_gp_fuses()</a>, <a class="el" href="a00022_source.html#l00263">flashc_error_status</a>, <a class="el" href="a00022_source.html#l00452">flashc_read_all_gp_fuses()</a>, <a class="el" href="a00022_source.html#l00446">flashc_read_gp_fuse_byte()</a>, <a class="el" href="a00022_source.html#l00530">flashc_write_gp_fuse_byte()</a>, and <a class="el" href="a00021_source.html#l00361">TRUE</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00573">flashc_set_gp_fuse_byte()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00482"></a>00482 {
<a name="l00483"></a>00483   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status;
<a name="l00484"></a>00484   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_gp_fuse_byte;
<a name="l00485"></a>00485   U64 value = <a class="code" href="a00022.html#a08124caa02942b5fa1d370a81a84dfb5" title="Reads all general-purpose fuses.">flashc_read_all_gp_fuses</a>();
<a name="l00486"></a>00486   <a class="code" href="a00022.html#acf3096dc9ecea92533c4688d7f90a0ef" title="Erases all general-purpose fuses.">flashc_erase_all_gp_fuses</a>(<a class="code" href="a00021.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l00487"></a>00487   error_status = <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00488"></a>00488   <span class="keywordflow">for</span> (current_gp_fuse_byte = 0; current_gp_fuse_byte &lt; 8; current_gp_fuse_byte++, value &gt;&gt;= 8)
<a name="l00489"></a>00489   {
<a name="l00490"></a>00490     <span class="keywordflow">if</span> (current_gp_fuse_byte != gp_fuse_byte)
<a name="l00491"></a>00491     {
<a name="l00492"></a>00492       <a class="code" href="a00022.html#a7670e69d41fe6a985ad898be25044caf" title="Writes a general-purpose fuse byte.">flashc_write_gp_fuse_byte</a>(current_gp_fuse_byte, value);
<a name="l00493"></a>00493       error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00494"></a>00494     }
<a name="l00495"></a>00495   }
<a name="l00496"></a>00496   <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a> = error_status;
<a name="l00497"></a>00497   <span class="keywordflow">return</span> (check) ? (<a class="code" href="a00022.html#a1ad2aab294e528795bbd835539b0b14e" title="Reads a general-purpose fuse byte.">flashc_read_gp_fuse_byte</a>(gp_fuse_byte) == 0xFF) : <a class="code" href="a00021.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00498"></a>00498 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a8de3bbd50094f548ca293f07b136cc6d"></a><!-- doxytag: member="flashc.c::flashc_erase_page" ref="a8de3bbd50094f548ca293f07b136cc6d" args="(int page_number, Bool check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_erase_page </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>check</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases a page. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_number</em>&nbsp;</td><td>The page number: </p>
<ul>
<li><code>0</code> to <code>(<a class="el" href="a00022.html#aafad0dcf645cc65acb5bc879558dac23" title="Gets the total number of pages in the flash array.">flashc_get_page_count()</a> - 1)</code>: a page number within the flash array; </li>
<li><code>&lt; 0</code>: the current page number. </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Whether to check erase: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the erase succeeded or always <code>TRUE</code> if erase check was not requested.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the command is applied to a page belonging to a locked region or to the bootloader protected area.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
An erase operation can only set bits. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00640">640</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00263">flashc_error_status</a>, <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>, <a class="el" href="a00022_source.html#l00633">flashc_quick_page_read()</a>, and <a class="el" href="a00021_source.html#l00361">TRUE</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00654">flashc_erase_all_pages()</a>, <a class="el" href="a00022_source.html#l00886">flashc_memcpy()</a>, and <a class="el" href="a00022_source.html#l00713">flashc_memset64()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00641"></a>00641 {
<a name="l00642"></a>00642   Bool page_erased = <a class="code" href="a00021.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00643"></a>00643   <a class="code" href="a00022.html#a8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_EP, page_number);
<a name="l00644"></a>00644   <span class="keywordflow">if</span> (check)
<a name="l00645"></a>00645   {
<a name="l00646"></a>00646     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00647"></a>00647     page_erased = <a class="code" href="a00022.html#acd50527aacf1d9ae11608fcc49a4fdcf" title="Applies the Quick Page Read command to a page.">flashc_quick_page_read</a>(-1);
<a name="l00648"></a>00648     <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a> |= error_status;
<a name="l00649"></a>00649   }
<a name="l00650"></a>00650   <span class="keywordflow">return</span> page_erased;
<a name="l00651"></a>00651 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a2ef66c5ffa0974223c44e151a8719b6d"></a><!-- doxytag: member="flashc.c::flashc_erase_user_page" ref="a2ef66c5ffa0974223c44e151a8719b6d" args="(Bool check)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_erase_user_page </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>check</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases the User page. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>check</em>&nbsp;</td><td>Whether to check erase: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the erase succeeded or always <code>TRUE</code> if erase check was not requested.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
An erase operation can only set bits. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00682">682</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>, <a class="el" href="a00022_source.html#l00675">flashc_quick_user_page_read()</a>, and <a class="el" href="a00021_source.html#l00361">TRUE</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00886">flashc_memcpy()</a>, and <a class="el" href="a00022_source.html#l00713">flashc_memset64()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00683"></a>00683 {
<a name="l00684"></a>00684   <a class="code" href="a00022.html#a8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_EUP, -1);
<a name="l00685"></a>00685   <span class="keywordflow">return</span> (check) ? <a class="code" href="a00022.html#a4cdef3bd6e4b7da53e4b7b7dc1adcd2f" title="Issues a Quick Page Read User Page command to the FLASHC.">flashc_quick_user_page_read</a>() : <a class="code" href="a00021.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00686"></a>00686 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a83ed88a41076163bd29ca80d30cb094f"></a><!-- doxytag: member="flashc.c::flashc_get_bootloader_protected_size" ref="a83ed88a41076163bd29ca80d30cb094f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_bootloader_protected_size </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the bootloader protected size. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The bootloader protected size in bytes. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00352">352</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00440">flashc_read_gp_fuse_bitfield()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00361">flashc_set_bootloader_protected_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00353"></a>00353 {
<a name="l00354"></a>00354   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bootprot = (1 &lt;&lt; AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE) - 1 -
<a name="l00355"></a>00355                           <a class="code" href="a00022.html#a0a0ce2691a31e0d529ec1143d61c4a86" title="Reads a general-purpose fuse bit-field.">flashc_read_gp_fuse_bitfield</a>(AVR32_FLASHC_FGPFRLO_BOOTPROT_OFFSET,
<a name="l00356"></a>00356                                                        AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE);
<a name="l00357"></a>00357   <span class="keywordflow">return</span> (bootprot) ? AVR32_FLASHC_PAGE_SIZE &lt;&lt; bootprot : 0;
<a name="l00358"></a>00358 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a36519235197ff4d6ab7f5adcb3fce6c1"></a><!-- doxytag: member="flashc.c::flashc_get_command" ref="a36519235197ff4d6ab7f5adcb3fce6c1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_command </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the last issued FLASHC command. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The last issued FLASHC command. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00286">286</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00287"></a>00287 {
<a name="l00288"></a>00288   <span class="keywordflow">return</span> (AVR32_FLASHC.fcmd &amp; AVR32_FLASHC_FCMD_CMD_MASK) &gt;&gt; AVR32_FLASHC_FCMD_CMD_OFFSET;
<a name="l00289"></a>00289 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae7d38c60001d5d8d00363a6cb07f89f0"></a><!-- doxytag: member="flashc.c::flashc_get_error_status" ref="ae7d38c60001d5d8d00363a6cb07f89f0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int flashc_get_error_status </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the error status of the FLASHC. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The error status of the FLASHC built up from <code>AVR32_FLASHC_FSR_LOCKE_MASK</code> and <code>AVR32_FLASHC_FSR_PROGE_MASK</code>.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This hardware error status is cleared by all functions reading the Flash Status Register (FSR). This function is therefore not part of the driver's API which instead presents <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a>. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00252">252</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00253"></a>00253 {
<a name="l00254"></a>00254   <span class="keywordflow">return</span> AVR32_FLASHC.fsr &amp; (AVR32_FLASHC_FSR_LOCKE_MASK |
<a name="l00255"></a>00255                              AVR32_FLASHC_FSR_PROGE_MASK);
<a name="l00256"></a>00256 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8071c315b02d038c49fa0bf89a40ba1b"></a><!-- doxytag: member="flashc.c::flashc_get_flash_size" ref="a8071c315b02d038c49fa0bf89a40ba1b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_flash_size </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of the whole flash array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The size of the whole flash array in bytes. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00078">78</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00117">flashc_get_page_count()</a>, <a class="el" href="a00022_source.html#l00886">flashc_memcpy()</a>, and <a class="el" href="a00022_source.html#l00713">flashc_memset64()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00079"></a>00079 {
<a name="l00080"></a>00080 <span class="preprocessor">#if (AVR32_FLASHC_H_VERSION &gt;= 300)</span>
<a name="l00081"></a>00081 <span class="preprocessor"></span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> FLASH_SIZE[1 &lt;&lt; AVR32_FLASHC_PR_FSZ_SIZE] =
<a name="l00082"></a>00082   {
<a name="l00083"></a>00083       4 &lt;&lt; 10,
<a name="l00084"></a>00084       8 &lt;&lt; 10,
<a name="l00085"></a>00085       16 &lt;&lt; 10,
<a name="l00086"></a>00086       32 &lt;&lt; 10,
<a name="l00087"></a>00087       48 &lt;&lt; 10,      
<a name="l00088"></a>00088       64 &lt;&lt; 10,
<a name="l00089"></a>00089       96  &lt;&lt; 10,
<a name="l00090"></a>00090      128 &lt;&lt; 10,
<a name="l00091"></a>00091      192 &lt;&lt; 10,
<a name="l00092"></a>00092      256 &lt;&lt; 10,
<a name="l00093"></a>00093      384 &lt;&lt; 10,
<a name="l00094"></a>00094      512 &lt;&lt; 10,
<a name="l00095"></a>00095      768 &lt;&lt; 10,
<a name="l00096"></a>00096     1024 &lt;&lt; 10,
<a name="l00097"></a>00097     2048 &lt;&lt; 10      
<a name="l00098"></a>00098   };
<a name="l00099"></a>00099   <span class="keywordflow">return</span> FLASH_SIZE[(AVR32_FLASHC.pr &amp; AVR32_FLASHC_PR_FSZ_MASK) &gt;&gt; AVR32_FLASHC_PR_FSZ_OFFSET];
<a name="l00100"></a>00100 <span class="preprocessor">#else // in older flashc version, FSZ is located in FSR register</span>
<a name="l00101"></a>00101 <span class="preprocessor"></span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> FLASH_SIZE[1 &lt;&lt; AVR32_FLASHC_FSR_FSZ_SIZE] =
<a name="l00102"></a>00102   {
<a name="l00103"></a>00103       32 &lt;&lt; 10,
<a name="l00104"></a>00104       64 &lt;&lt; 10,
<a name="l00105"></a>00105      128 &lt;&lt; 10,
<a name="l00106"></a>00106      256 &lt;&lt; 10,
<a name="l00107"></a>00107      384 &lt;&lt; 10,
<a name="l00108"></a>00108      512 &lt;&lt; 10,
<a name="l00109"></a>00109      768 &lt;&lt; 10,
<a name="l00110"></a>00110     1024 &lt;&lt; 10
<a name="l00111"></a>00111   };
<a name="l00112"></a>00112   <span class="keywordflow">return</span> FLASH_SIZE[(AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_FSZ_MASK) &gt;&gt; AVR32_FLASHC_FSR_FSZ_OFFSET];
<a name="l00113"></a>00113 <span class="preprocessor">#endif  </span>
<a name="l00114"></a>00114 <span class="preprocessor"></span>}
</pre></div></p>

</div>
</div>
<a class="anchor" id="aafad0dcf645cc65acb5bc879558dac23"></a><!-- doxytag: member="flashc.c::flashc_get_page_count" ref="aafad0dcf645cc65acb5bc879558dac23" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_page_count </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the total number of pages in the flash array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The total number of pages in the flash array. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00117">117</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00078">flashc_get_flash_size()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00654">flashc_erase_all_pages()</a>, and <a class="el" href="a00022_source.html#l00123">flashc_get_page_count_per_region()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00118"></a>00118 {
<a name="l00119"></a>00119   <span class="keywordflow">return</span> <a class="code" href="a00022.html#a8071c315b02d038c49fa0bf89a40ba1b" title="Gets the size of the whole flash array.">flashc_get_flash_size</a>() / AVR32_FLASHC_PAGE_SIZE;
<a name="l00120"></a>00120 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a8910bcde3235e2af0770fbd2412b05bc"></a><!-- doxytag: member="flashc.c::flashc_get_page_count_per_region" ref="a8910bcde3235e2af0770fbd2412b05bc" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_page_count_per_region </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of pages in each flash region. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of pages in each flash region. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00123">123</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00023_source.html#l00056">AVR32_FLASHC_REGIONS</a>, and <a class="el" href="a00022_source.html#l00117">flashc_get_page_count()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00129">flashc_get_page_region()</a>, and <a class="el" href="a00022_source.html#l00135">flashc_get_region_first_page_number()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00124"></a>00124 {
<a name="l00125"></a>00125   <span class="keywordflow">return</span> <a class="code" href="a00022.html#aafad0dcf645cc65acb5bc879558dac23" title="Gets the total number of pages in the flash array.">flashc_get_page_count</a>() / <a class="code" href="a00023.html#aa70e373b96ff9c00883f284ca308e592" title="Number of flash regions defined by the FLASHC.">AVR32_FLASHC_REGIONS</a>;
<a name="l00126"></a>00126 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="adb51a37e3153c24e5dd6cf06daac0e21"></a><!-- doxytag: member="flashc.c::flashc_get_page_number" ref="adb51a37e3153c24e5dd6cf06daac0e21" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_page_number </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the current FLASHC page number. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The current FLASHC page number. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00292">292</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00129">flashc_get_page_region()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00293"></a>00293 {
<a name="l00294"></a>00294   <span class="keywordflow">return</span> (AVR32_FLASHC.fcmd &amp; AVR32_FLASHC_FCMD_PAGEN_MASK) &gt;&gt; AVR32_FLASHC_FCMD_PAGEN_OFFSET;
<a name="l00295"></a>00295 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac5871dc98c8812b0413efd6456508999"></a><!-- doxytag: member="flashc.c::flashc_get_page_region" ref="ac5871dc98c8812b0413efd6456508999" args="(int page_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_page_region </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page_number</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the region number of a page. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_number</em>&nbsp;</td><td>The page number: </p>
<ul>
<li><code>0</code> to <code>(<a class="el" href="a00022.html#aafad0dcf645cc65acb5bc879558dac23" title="Gets the total number of pages in the flash array.">flashc_get_page_count()</a> - 1)</code>: a page number within the flash array; </li>
<li><code>&lt; 0</code>: the current page number.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The region number of the specified page. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00129">129</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00123">flashc_get_page_count_per_region()</a>, and <a class="el" href="a00022_source.html#l00292">flashc_get_page_number()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00389">flashc_is_page_region_locked()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00130"></a>00130 {
<a name="l00131"></a>00131   <span class="keywordflow">return</span> ((page_number &gt;= 0) ? page_number : <a class="code" href="a00022.html#adb51a37e3153c24e5dd6cf06daac0e21" title="Gets the current FLASHC page number.">flashc_get_page_number</a>()) / <a class="code" href="a00022.html#a8910bcde3235e2af0770fbd2412b05bc" title="Gets the number of pages in each flash region.">flashc_get_page_count_per_region</a>();
<a name="l00132"></a>00132 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a43b14107d406ea9025f8947490c9ddcd"></a><!-- doxytag: member="flashc.c::flashc_get_region_first_page_number" ref="a43b14107d406ea9025f8947490c9ddcd" args="(unsigned int region)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_region_first_page_number </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>region</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of the first page of a region. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>The region number: <code>0</code> to <code>(AVR32_FLASHC_REGIONS - 1)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of the first page of the specified region. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00135">135</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00123">flashc_get_page_count_per_region()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00407">flashc_lock_region()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00136"></a>00136 {
<a name="l00137"></a>00137   <span class="keywordflow">return</span> region * <a class="code" href="a00022.html#a8910bcde3235e2af0770fbd2412b05bc" title="Gets the number of pages in each flash region.">flashc_get_page_count_per_region</a>();
<a name="l00138"></a>00138 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a52784dbdd246c6c320e5041026d4da08"></a><!-- doxytag: member="flashc.c::flashc_get_wait_state" ref="a52784dbdd246c6c320e5041026d4da08" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_get_wait_state </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of wait states of flash read accesses. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The number of wait states of flash read accesses. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00149">149</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00150"></a>00150 {
<a name="l00151"></a>00151   <span class="keywordflow">return</span> (AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_FWS_MASK) &gt;&gt; AVR32_FLASHC_FCR_FWS_OFFSET;
<a name="l00152"></a>00152 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a64607cf8bb7de7e226973c7d9a10170d"></a><!-- doxytag: member="flashc.c::flashc_is_external_privileged_fetch_locked" ref="a64607cf8bb7de7e226973c7d9a10170d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_external_privileged_fetch_locked </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether external privileged fetch is locked. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether external privileged fetch is locked. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00377">377</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00434">flashc_read_gp_fuse_bit()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00378"></a>00378 {
<a name="l00379"></a>00379   <span class="keywordflow">return</span> (!<a class="code" href="a00022.html#ae6203d2e69ff15d59366c28bf8e26a7e" title="Reads a general-purpose fuse bit.">flashc_read_gp_fuse_bit</a>(AVR32_FLASHC_FGPFRLO_EPFL_OFFSET));
<a name="l00380"></a>00380 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="aa5e4eb7ae688be5d59fca4bb6a326447"></a><!-- doxytag: member="flashc.c::flashc_is_lock_error" ref="aa5e4eb7ae688be5d59fca4bb6a326447" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_lock_error </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether a Lock Error has occurred during the last function called that issued one or more FLASHC commands. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether a Lock Error has occurred during the last function called that issued one or more FLASHC commands. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00266">266</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00263">flashc_error_status</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00267"></a>00267 {
<a name="l00268"></a>00268   <span class="keywordflow">return</span> ((<a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a> &amp; AVR32_FLASHC_FSR_LOCKE_MASK) != 0);
<a name="l00269"></a>00269 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ad9a950413a6b9d64a832b82ebaa2c38d"></a><!-- doxytag: member="flashc.c::flashc_is_lock_error_int_enabled" ref="ad9a950413a6b9d64a832b82ebaa2c38d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_lock_error_int_enabled </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether the Lock Error interrupt is enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the Lock Error interrupt is enabled. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00191">191</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00192"></a>00192 {
<a name="l00193"></a>00193   <span class="keywordflow">return</span> ((AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_LOCKE_MASK) != 0);
<a name="l00194"></a>00194 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="acdea4bfb0cb1066fba239a9302196ee5"></a><!-- doxytag: member="flashc.c::flashc_is_page_erased" ref="acdea4bfb0cb1066fba239a9302196ee5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_page_erased </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether the page to which the last Quick Page Read or Quick Page Read User Page command was applied was erased. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the page to which the last Quick Page Read or Quick Page Read User Page command was applied was erased. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00627">627</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00633">flashc_quick_page_read()</a>, and <a class="el" href="a00022_source.html#l00675">flashc_quick_user_page_read()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00628"></a>00628 {
<a name="l00629"></a>00629   <span class="keywordflow">return</span> ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_QPRR_MASK) != 0);
<a name="l00630"></a>00630 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="afa30fe317124244e8c5a7fcc7a0ba44b"></a><!-- doxytag: member="flashc.c::flashc_is_page_region_locked" ref="afa30fe317124244e8c5a7fcc7a0ba44b" args="(int page_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_page_region_locked </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page_number</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether the region of a page is locked. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_number</em>&nbsp;</td><td>The page number: </p>
<ul>
<li><code>0</code> to <code>(<a class="el" href="a00022.html#aafad0dcf645cc65acb5bc879558dac23" title="Gets the total number of pages in the flash array.">flashc_get_page_count()</a> - 1)</code>: a page number within the flash array; </li>
<li><code>&lt; 0</code>: the current page number.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the region of the specified page is locked. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00389">389</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00129">flashc_get_page_region()</a>, and <a class="el" href="a00022_source.html#l00395">flashc_is_region_locked()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00390"></a>00390 {
<a name="l00391"></a>00391   <span class="keywordflow">return</span> <a class="code" href="a00022.html#ae6e9e45c046406a645ffac5e3fd62d40" title="Tells whether a region is locked.">flashc_is_region_locked</a>(<a class="code" href="a00022.html#ac5871dc98c8812b0413efd6456508999" title="Gets the region number of a page.">flashc_get_page_region</a>(page_number));
<a name="l00392"></a>00392 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="aec6b3818f1a6a0d4bf69838c2743de85"></a><!-- doxytag: member="flashc.c::flashc_is_prog_error_int_enabled" ref="aec6b3818f1a6a0d4bf69838c2743de85" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_prog_error_int_enabled </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether the Programming Error interrupt is enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the Programming Error interrupt is enabled. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00205">205</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00206"></a>00206 {
<a name="l00207"></a>00207   <span class="keywordflow">return</span> ((AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_PROGE_MASK) != 0);
<a name="l00208"></a>00208 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a2556a29213a1be8df40df2f8868077bd"></a><!-- doxytag: member="flashc.c::flashc_is_programming_error" ref="a2556a29213a1be8df40df2f8868077bd" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_programming_error </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether a Programming Error has occurred during the last function called that issued one or more FLASHC commands. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether a Programming Error has occurred during the last function called that issued one or more FLASHC commands. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00272">272</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00263">flashc_error_status</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00273"></a>00273 {
<a name="l00274"></a>00274   <span class="keywordflow">return</span> ((<a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a> &amp; AVR32_FLASHC_FSR_PROGE_MASK) != 0);
<a name="l00275"></a>00275 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ac47ea338258641e6fe9361885a116c39"></a><!-- doxytag: member="flashc.c::flashc_is_ready" ref="ac47ea338258641e6fe9361885a116c39" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_ready </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether the FLASHC is ready to run a new command. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the FLASHC is ready to run a new command. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00227">227</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00233">flashc_default_wait_until_ready()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00228"></a>00228 {
<a name="l00229"></a>00229   <span class="keywordflow">return</span> ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_FRDY_MASK) != 0);
<a name="l00230"></a>00230 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a517223d37600d347adc24fed238ebaf7"></a><!-- doxytag: member="flashc.c::flashc_is_ready_int_enabled" ref="a517223d37600d347adc24fed238ebaf7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_ready_int_enabled </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether the Flash Ready interrupt is enabled. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the Flash Ready interrupt is enabled. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00177">177</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00178"></a>00178 {
<a name="l00179"></a>00179   <span class="keywordflow">return</span> ((AVR32_FLASHC.fcr &amp; AVR32_FLASHC_FCR_FRDY_MASK) != 0);
<a name="l00180"></a>00180 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae6e9e45c046406a645ffac5e3fd62d40"></a><!-- doxytag: member="flashc.c::flashc_is_region_locked" ref="ae6e9e45c046406a645ffac5e3fd62d40" args="(unsigned int region)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_region_locked </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>region</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether a region is locked. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>The region number: <code>0</code> to <code>(AVR32_FLASHC_REGIONS - 1)</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the specified region is locked. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00395">395</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00023_source.html#l00056">AVR32_FLASHC_REGIONS</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00389">flashc_is_page_region_locked()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00396"></a>00396 {
<a name="l00397"></a>00397   <span class="keywordflow">return</span> ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_LOCK0_MASK &lt;&lt; (region &amp; (<a class="code" href="a00023.html#aa70e373b96ff9c00883f284ca308e592" title="Number of flash regions defined by the FLASHC.">AVR32_FLASHC_REGIONS</a> - 1))) != 0);
<a name="l00398"></a>00398 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a03df73f0be08f7bc503f3c336b1abdc1"></a><!-- doxytag: member="flashc.c::flashc_is_security_bit_active" ref="a03df73f0be08f7bc503f3c336b1abdc1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_is_security_bit_active </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Tells whether the Security bit is active. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the Security bit is active. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00340">340</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00341"></a>00341 {
<a name="l00342"></a>00342   <span class="keywordflow">return</span> ((AVR32_FLASHC.fsr &amp; AVR32_FLASHC_FSR_SECURITY_MASK) != 0);
<a name="l00343"></a>00343 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a8045c427c32cf3617e861067d76c9c11"></a><!-- doxytag: member="flashc.c::flashc_issue_command" ref="a8045c427c32cf3617e861067d76c9c11" args="(unsigned int command, int page_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_issue_command </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page_number</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Issues a FLASHC command. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>command</em>&nbsp;</td><td>The command: <code>AVR32_FLASHC_FCMD_CMD_x</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>page_number</em>&nbsp;</td><td>The page number to apply the command to: </p>
<ul>
<li><code>0</code> to <code>(<a class="el" href="a00022.html#aafad0dcf645cc65acb5bc879558dac23" title="Gets the total number of pages in the flash array.">flashc_get_page_count()</a> - 1)</code>: a page number within the flash array; </li>
<li><code>&lt; 0</code>: use this to apply the command to the current page number or if the command does not apply to any page number; </li>
<li>this argument may have other meanings according to the command. See the FLASHC chapter of the MCU datasheet.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the command violates the protection mechanism.</dd>
<dd>
A Programming Error is issued if the command is invalid.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00298">298</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00067">u_avr32_flashc_fcmd_t::FCMD</a>, <a class="el" href="a00022_source.html#l00066">u_avr32_flashc_fcmd_t::fcmd</a>, <a class="el" href="a00022_source.html#l00263">flashc_error_status</a>, <a class="el" href="a00022_source.html#l00252">flashc_get_error_status()</a>, and <a class="el" href="a00022_source.html#l00239">flashc_wait_until_ready</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00346">flashc_activate_security_bit()</a>, <a class="el" href="a00022_source.html#l00621">flashc_clear_page_buffer()</a>, <a class="el" href="a00022_source.html#l00326">flashc_erase_all()</a>, <a class="el" href="a00022_source.html#l00501">flashc_erase_all_gp_fuses()</a>, <a class="el" href="a00022_source.html#l00458">flashc_erase_gp_fuse_bit()</a>, <a class="el" href="a00022_source.html#l00640">flashc_erase_page()</a>, <a class="el" href="a00022_source.html#l00682">flashc_erase_user_page()</a>, <a class="el" href="a00022_source.html#l00401">flashc_lock_page_region()</a>, <a class="el" href="a00022_source.html#l00320">flashc_no_operation()</a>, <a class="el" href="a00022_source.html#l00633">flashc_quick_page_read()</a>, <a class="el" href="a00022_source.html#l00675">flashc_quick_user_page_read()</a>, <a class="el" href="a00022_source.html#l00508">flashc_write_gp_fuse_bit()</a>, <a class="el" href="a00022_source.html#l00530">flashc_write_gp_fuse_byte()</a>, <a class="el" href="a00022_source.html#l00669">flashc_write_page()</a>, and <a class="el" href="a00022_source.html#l00689">flashc_write_user_page()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00299"></a>00299 {
<a name="l00300"></a>00300   <a class="code" href="a00010.html">u_avr32_flashc_fcmd_t</a> u_avr32_flashc_fcmd;
<a name="l00301"></a>00301   <a class="code" href="a00022.html#a180c9966f5242650e00e4a231956acec" title="Pointer to the function used by the driver when it needs to wait until the FLASHC...">flashc_wait_until_ready</a>();
<a name="l00302"></a>00302   u_avr32_flashc_fcmd.<a class="code" href="a00010.html#a6e34d6a9df4c1f26204d439fd5314700">fcmd</a> = AVR32_FLASHC.fcmd;
<a name="l00303"></a>00303   u_avr32_flashc_fcmd.<a class="code" href="a00010.html#a417db73c116267ff3545f9af41fac150">FCMD</a>.cmd = command;
<a name="l00304"></a>00304   <span class="keywordflow">if</span> (page_number &gt;= 0) u_avr32_flashc_fcmd.<a class="code" href="a00010.html#a417db73c116267ff3545f9af41fac150">FCMD</a>.pagen = page_number;
<a name="l00305"></a>00305   u_avr32_flashc_fcmd.<a class="code" href="a00010.html#a417db73c116267ff3545f9af41fac150">FCMD</a>.key = AVR32_FLASHC_FCMD_KEY_KEY;
<a name="l00306"></a>00306   AVR32_FLASHC.fcmd = u_avr32_flashc_fcmd.<a class="code" href="a00010.html#a6e34d6a9df4c1f26204d439fd5314700">fcmd</a>;
<a name="l00307"></a>00307   <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a> = <a class="code" href="a00022.html#ae7d38c60001d5d8d00363a6cb07f89f0" title="Gets the error status of the FLASHC.">flashc_get_error_status</a>();
<a name="l00308"></a>00308   <a class="code" href="a00022.html#a180c9966f5242650e00e4a231956acec" title="Pointer to the function used by the driver when it needs to wait until the FLASHC...">flashc_wait_until_ready</a>();
<a name="l00309"></a>00309 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a7c05cca97169ee6888828c40243c0191"></a><!-- doxytag: member="flashc.c::flashc_lock_all_regions" ref="a7c05cca97169ee6888828c40243c0191" args="(Bool lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_lock_all_regions </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>lock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locks or unlocks all regions. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Whether to lock the regions: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00413">413</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00023_source.html#l00056">AVR32_FLASHC_REGIONS</a>, <a class="el" href="a00022_source.html#l00263">flashc_error_status</a>, and <a class="el" href="a00022_source.html#l00407">flashc_lock_region()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00414"></a>00414 {
<a name="l00415"></a>00415   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = 0;
<a name="l00416"></a>00416   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> region = <a class="code" href="a00023.html#aa70e373b96ff9c00883f284ca308e592" title="Number of flash regions defined by the FLASHC.">AVR32_FLASHC_REGIONS</a>;
<a name="l00417"></a>00417   <span class="keywordflow">while</span> (region)
<a name="l00418"></a>00418   {
<a name="l00419"></a>00419     <a class="code" href="a00022.html#a026f45da4ae8afea4d40066d3523ee3b" title="Locks or unlocks a region.">flashc_lock_region</a>(--region, lock);
<a name="l00420"></a>00420     error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00421"></a>00421   }
<a name="l00422"></a>00422   <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a> = error_status;
<a name="l00423"></a>00423 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a5b5725c807435b40115f4577a79b88b2"></a><!-- doxytag: member="flashc.c::flashc_lock_external_privileged_fetch" ref="a5b5725c807435b40115f4577a79b88b2" args="(Bool lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_lock_external_privileged_fetch </td>
          <td>(</td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>lock</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locks or unlocks external privileged fetch. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Whether to lock external privileged fetch: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00383">383</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00549">flashc_set_gp_fuse_bit()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00384"></a>00384 {
<a name="l00385"></a>00385   <a class="code" href="a00022.html#a5c5442a988c608baea0d1c0b841badca" title="Sets a general-purpose fuse bit with the appropriate erase and write operations.">flashc_set_gp_fuse_bit</a>(AVR32_FLASHC_FGPFRLO_EPFL_OFFSET, !lock);
<a name="l00386"></a>00386 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="aa79c8c0023a4813a08cff039ccd003ab"></a><!-- doxytag: member="flashc.c::flashc_lock_page_region" ref="aa79c8c0023a4813a08cff039ccd003ab" args="(int page_number, Bool lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_lock_page_region </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page_number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>lock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locks or unlocks the region of a page. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_number</em>&nbsp;</td><td>The page number: </p>
<ul>
<li><code>0</code> to <code>(<a class="el" href="a00022.html#aafad0dcf645cc65acb5bc879558dac23" title="Gets the total number of pages in the flash array.">flashc_get_page_count()</a> - 1)</code>: a page number within the flash array; </li>
<li><code>&lt; 0</code>: the current page number. </li>
</ul>
</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Whether to lock the region of the specified page: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00401">401</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00407">flashc_lock_region()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00402"></a>00402 {
<a name="l00403"></a>00403   <a class="code" href="a00022.html#a8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>((lock) ? AVR32_FLASHC_FCMD_CMD_LP : AVR32_FLASHC_FCMD_CMD_UP, page_number);
<a name="l00404"></a>00404 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a026f45da4ae8afea4d40066d3523ee3b"></a><!-- doxytag: member="flashc.c::flashc_lock_region" ref="a026f45da4ae8afea4d40066d3523ee3b" args="(unsigned int region, Bool lock)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_lock_region </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>lock</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Locks or unlocks a region. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>region</em>&nbsp;</td><td>The region number: <code>0</code> to <code>(AVR32_FLASHC_REGIONS - 1)</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lock</em>&nbsp;</td><td>Whether to lock the specified region: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00407">407</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00135">flashc_get_region_first_page_number()</a>, and <a class="el" href="a00022_source.html#l00401">flashc_lock_page_region()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00413">flashc_lock_all_regions()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00408"></a>00408 {
<a name="l00409"></a>00409   <a class="code" href="a00022.html#aa79c8c0023a4813a08cff039ccd003ab" title="Locks or unlocks the region of a page.">flashc_lock_page_region</a>(<a class="code" href="a00022.html#a43b14107d406ea9025f8947490c9ddcd" title="Gets the number of the first page of a region.">flashc_get_region_first_page_number</a>(region), lock);
<a name="l00410"></a>00410 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="ab257e261b58cabbd30f176287882886e"></a><!-- doxytag: member="flashc.c::flashc_memcpy" ref="ab257e261b58cabbd30f176287882886e" args="(volatile void *dst, const void *src, size_t nbytes, Bool erase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile void* flashc_memcpy </td>
          <td>(</td>
          <td class="paramtype">volatile void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>erase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the source pointed to by <em>src</em>. </p>
<p>The destination areas that are not within the flash array or the User page are ignored.</p>
<p>All pointer and size alignments are supported.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Pointer to flash destination. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Pointer to source data. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbytes</em>&nbsp;</td><td>Number of bytes to copy. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>erase</em>&nbsp;</td><td>Whether to erase before writing: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of <em>dst</em>.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>If copying takes place between areas that overlap, the behavior is undefined.</dd>
<dd>
This function may be called with <em>erase</em> set to <code>FALSE</code> only if the destination consists only of erased words, i.e. this function can not be used to write only one bit of a previously written word. E.g., if <code>0x00000001</code> then <code>0xFFFFFFFE</code> are written to a word, the resulting value in flash may be different from <code>0x00000000</code>.</dd>
<dd>
A Lock Error is issued if the command is applied to pages belonging to a locked region or to the bootloader protected area.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00886">886</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00021_source.html#l00360">FALSE</a>, <a class="el" href="a00022_source.html#l00621">flashc_clear_page_buffer()</a>, <a class="el" href="a00022_source.html#l00640">flashc_erase_page()</a>, <a class="el" href="a00022_source.html#l00682">flashc_erase_user_page()</a>, <a class="el" href="a00022_source.html#l00263">flashc_error_status</a>, <a class="el" href="a00022_source.html#l00078">flashc_get_flash_size()</a>, <a class="el" href="a00022_source.html#l00669">flashc_write_page()</a>, <a class="el" href="a00022_source.html#l00689">flashc_write_user_page()</a>, and <a class="el" href="a00021_source.html#l00361">TRUE</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00887"></a>00887 {
<a name="l00888"></a>00888   <span class="comment">// Use aggregated pointers to have several alignments available for a same address.</span>
<a name="l00889"></a>00889   UnionCVPtr flash_array_end;
<a name="l00890"></a>00890   UnionVPtr dest;
<a name="l00891"></a>00891   UnionCPtr source;
<a name="l00892"></a>00892   StructCVPtr dest_end;
<a name="l00893"></a>00893   UnionCVPtr flash_page_source_end;
<a name="l00894"></a>00894   Bool incomplete_flash_page_end;
<a name="l00895"></a>00895   Union64 flash_dword;
<a name="l00896"></a>00896   Bool flash_dword_pending = <a class="code" href="a00021.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>;
<a name="l00897"></a>00897   UnionVPtr tmp;
<a name="l00898"></a>00898   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = 0;
<a name="l00899"></a>00899   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, j;
<a name="l00900"></a>00900 
<a name="l00901"></a>00901   <span class="comment">// Reformat arguments.</span>
<a name="l00902"></a>00902   flash_array_end.u8ptr = AVR32_FLASH + <a class="code" href="a00022.html#a8071c315b02d038c49fa0bf89a40ba1b" title="Gets the size of the whole flash array.">flashc_get_flash_size</a>();
<a name="l00903"></a>00903   dest.u8ptr = dst;
<a name="l00904"></a>00904   source.u8ptr = src;
<a name="l00905"></a>00905   dest_end.u8ptr = dest.u8ptr + nbytes;
<a name="l00906"></a>00906 
<a name="l00907"></a>00907   <span class="comment">// If destination is outside flash, go to next flash page if any.</span>
<a name="l00908"></a>00908   <span class="keywordflow">if</span> (dest.u8ptr &lt; AVR32_FLASH)
<a name="l00909"></a>00909   {
<a name="l00910"></a>00910     source.u8ptr += AVR32_FLASH - dest.u8ptr;
<a name="l00911"></a>00911     dest.u8ptr = AVR32_FLASH;
<a name="l00912"></a>00912   }
<a name="l00913"></a>00913   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (flash_array_end.u8ptr &lt;= dest.u8ptr &amp;&amp; dest.u8ptr &lt; AVR32_FLASHC_USER_PAGE)
<a name="l00914"></a>00914   {
<a name="l00915"></a>00915     source.u8ptr += AVR32_FLASHC_USER_PAGE - dest.u8ptr;
<a name="l00916"></a>00916     dest.u8ptr = AVR32_FLASHC_USER_PAGE;
<a name="l00917"></a>00917   }
<a name="l00918"></a>00918 
<a name="l00919"></a>00919   <span class="comment">// If end of destination is outside flash, move it to the end of the previous flash page if any.</span>
<a name="l00920"></a>00920   <span class="keywordflow">if</span> (dest_end.u8ptr &gt; AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE)
<a name="l00921"></a>00921   {
<a name="l00922"></a>00922     dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
<a name="l00923"></a>00923   }
<a name="l00924"></a>00924   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (AVR32_FLASHC_USER_PAGE &gt;= dest_end.u8ptr &amp;&amp; dest_end.u8ptr &gt; flash_array_end.u8ptr)
<a name="l00925"></a>00925   {
<a name="l00926"></a>00926     dest_end.u8ptr = flash_array_end.u8ptr;
<a name="l00927"></a>00927   }
<a name="l00928"></a>00928 
<a name="l00929"></a>00929   <span class="comment">// Align each end of destination pointer with its natural boundary.</span>
<a name="l00930"></a>00930   dest_end.u16ptr = (U16 *)Align_down((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U16));
<a name="l00931"></a>00931   dest_end.u32ptr = (U32 *)Align_down((U32)dest_end.u16ptr, <span class="keyword">sizeof</span>(U32));
<a name="l00932"></a>00932   dest_end.u64ptr = (U64 *)Align_down((U32)dest_end.u32ptr, <span class="keyword">sizeof</span>(U64));
<a name="l00933"></a>00933 
<a name="l00934"></a>00934   <span class="comment">// While end of destination is not reached...</span>
<a name="l00935"></a>00935   <span class="keywordflow">while</span> (dest.u8ptr &lt; dest_end.u8ptr)
<a name="l00936"></a>00936   {
<a name="l00937"></a>00937     <span class="comment">// Clear the page buffer in order to prepare data for a flash page write.</span>
<a name="l00938"></a>00938     <a class="code" href="a00022.html#affafe9cb74731d817b721d2a52093412" title="Clears the page buffer.">flashc_clear_page_buffer</a>();
<a name="l00939"></a>00939     error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00940"></a>00940 
<a name="l00941"></a>00941     <span class="comment">// Determine where the source data will end in the current flash page.</span>
<a name="l00942"></a>00942     flash_page_source_end.u64ptr =
<a name="l00943"></a>00943       (U64 *)min((U32)dest_end.u64ptr,
<a name="l00944"></a>00944                  Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) + AVR32_FLASHC_PAGE_SIZE);
<a name="l00945"></a>00945 
<a name="l00946"></a>00946     <span class="comment">// Determine if the current destination page has an incomplete end.</span>
<a name="l00947"></a>00947     incomplete_flash_page_end = (Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) &gt;=
<a name="l00948"></a>00948                                  Align_down((U32)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));
<a name="l00949"></a>00949 
<a name="l00950"></a>00950     <span class="comment">// If destination does not point to the beginning of the current flash page...</span>
<a name="l00951"></a>00951     <span class="keywordflow">if</span> (!Test_align((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE))
<a name="l00952"></a>00952     {
<a name="l00953"></a>00953       <span class="comment">// Fill the beginning of the page buffer with the current flash page data.</span>
<a name="l00954"></a>00954       <span class="comment">// This is required by the hardware, even if page erase is not requested,</span>
<a name="l00955"></a>00955       <span class="comment">// in order to be able to write successfully to erased parts of flash</span>
<a name="l00956"></a>00956       <span class="comment">// pages that have already been written to.</span>
<a name="l00957"></a>00957       <span class="keywordflow">for</span> (tmp.u8ptr = (U8 *)Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
<a name="l00958"></a>00958            tmp.u64ptr &lt; (U64 *)Align_down((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64));
<a name="l00959"></a>00959            tmp.u64ptr++)
<a name="l00960"></a>00960         *tmp.u64ptr = *tmp.u64ptr;
<a name="l00961"></a>00961 
<a name="l00962"></a>00962       <span class="comment">// If destination is not 64-bit aligned...</span>
<a name="l00963"></a>00963       if (!Test_align((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64)))
<a name="l00964"></a>00964       {
<a name="l00965"></a>00965         <span class="comment">// Fill the beginning of the flash double-word buffer with the current</span>
<a name="l00966"></a>00966         <span class="comment">// flash page data.</span>
<a name="l00967"></a>00967         <span class="comment">// This is required by the hardware, even if page erase is not</span>
<a name="l00968"></a>00968         <span class="comment">// requested, in order to be able to write successfully to erased parts</span>
<a name="l00969"></a>00969         <span class="comment">// of flash pages that have already been written to.</span>
<a name="l00970"></a>00970         <span class="keywordflow">for</span> (i = 0; i &lt; Get_align((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64)); i++)
<a name="l00971"></a>00971           flash_dword.u8[i] = *tmp.u8ptr++;
<a name="l00972"></a>00972 
<a name="l00973"></a>00973         <span class="comment">// Fill the end of the flash double-word buffer with the source data.</span>
<a name="l00974"></a>00974         for (; i &lt; <span class="keyword">sizeof</span>(U64); i++)
<a name="l00975"></a>00975           flash_dword.u8[i] = *source.u8ptr++;
<a name="l00976"></a>00976 
<a name="l00977"></a>00977         <span class="comment">// Align the destination pointer with its 64-bit boundary.</span>
<a name="l00978"></a>00978         dest.u64ptr = (U64 *)Align_down((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64));
<a name="l00979"></a>00979 
<a name="l00980"></a>00980         <span class="comment">// If the current destination double-word is not the last one...</span>
<a name="l00981"></a>00981         <span class="keywordflow">if</span> (dest.u64ptr &lt; dest_end.u64ptr)
<a name="l00982"></a>00982         {
<a name="l00983"></a>00983           <span class="comment">// Write the flash double-word buffer to the page buffer.</span>
<a name="l00984"></a>00984           *dest.u64ptr++ = flash_dword.u64;
<a name="l00985"></a>00985         }
<a name="l00986"></a>00986         <span class="comment">// If the current destination double-word is the last one, the flash</span>
<a name="l00987"></a>00987         <span class="comment">// double-word buffer must be kept for later.</span>
<a name="l00988"></a>00988         <span class="keywordflow">else</span> flash_dword_pending = <a class="code" href="a00021.html#aa8cecfc5c5c054d2875c03e77b7be15d">TRUE</a>;
<a name="l00989"></a>00989       }
<a name="l00990"></a>00990     }
<a name="l00991"></a>00991 
<a name="l00992"></a>00992     <span class="comment">// Read the source data with the maximal possible alignment and write it to</span>
<a name="l00993"></a>00993     <span class="comment">// the page buffer with 64-bit alignment.</span>
<a name="l00994"></a>00994     <span class="keywordflow">switch</span> (Get_align((U32)source.u8ptr, <span class="keyword">sizeof</span>(U32)))
<a name="l00995"></a>00995     {
<a name="l00996"></a>00996     <span class="keywordflow">case</span> 0:
<a name="l00997"></a>00997       <span class="keywordflow">for</span> (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
<a name="l00998"></a>00998         *dest.u64ptr++ = *source.u64ptr++;
<a name="l00999"></a>00999       <span class="keywordflow">break</span>;
<a name="l01000"></a>01000 
<a name="l01001"></a>01001     <span class="keywordflow">case</span> <span class="keyword">sizeof</span>(U16):
<a name="l01002"></a>01002       <span class="keywordflow">for</span> (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
<a name="l01003"></a>01003       {
<a name="l01004"></a>01004         <span class="keywordflow">for</span> (j = 0; j &lt; <span class="keyword">sizeof</span>(U64) / <span class="keyword">sizeof</span>(U16); j++) flash_dword.u16[j] = *source.u16ptr++;
<a name="l01005"></a>01005         *dest.u64ptr++ = flash_dword.u64;
<a name="l01006"></a>01006       }
<a name="l01007"></a>01007       <span class="keywordflow">break</span>;
<a name="l01008"></a>01008 
<a name="l01009"></a>01009     <span class="keywordflow">default</span>:
<a name="l01010"></a>01010       <span class="keywordflow">for</span> (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
<a name="l01011"></a>01011       {
<a name="l01012"></a>01012         <span class="keywordflow">for</span> (j = 0; j &lt; <span class="keyword">sizeof</span>(U64); j++) flash_dword.u8[j] = *source.u8ptr++;
<a name="l01013"></a>01013         *dest.u64ptr++ = flash_dword.u64;
<a name="l01014"></a>01014       }
<a name="l01015"></a>01015     }
<a name="l01016"></a>01016 
<a name="l01017"></a>01017     <span class="comment">// If the current destination page has an incomplete end...</span>
<a name="l01018"></a>01018     <span class="keywordflow">if</span> (incomplete_flash_page_end)
<a name="l01019"></a>01019     {
<a name="l01020"></a>01020       <span class="comment">// If the flash double-word buffer is in use, do not initialize it.</span>
<a name="l01021"></a>01021       <span class="keywordflow">if</span> (flash_dword_pending) i = Get_align((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U64));
<a name="l01022"></a>01022       <span class="comment">// If the flash double-word buffer is free...</span>
<a name="l01023"></a>01023       <span class="keywordflow">else</span>
<a name="l01024"></a>01024       {
<a name="l01025"></a>01025         <span class="comment">// Fill the beginning of the flash double-word buffer with the source data.</span>
<a name="l01026"></a>01026         <span class="keywordflow">for</span> (i = 0; i &lt; Get_align((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U64)); i++)
<a name="l01027"></a>01027           flash_dword.u8[i] = *source.u8ptr++;
<a name="l01028"></a>01028       }
<a name="l01029"></a>01029 
<a name="l01030"></a>01030       <span class="comment">// This is required by the hardware, even if page erase is not requested,</span>
<a name="l01031"></a>01031       <span class="comment">// in order to be able to write successfully to erased parts of flash</span>
<a name="l01032"></a>01032       <span class="comment">// pages that have already been written to.</span>
<a name="l01033"></a>01033       {
<a name="l01034"></a>01034         tmp.u8ptr = (<span class="keyword">volatile</span> U8 *)dest_end.u8ptr;
<a name="l01035"></a>01035 
<a name="l01036"></a>01036         <span class="comment">// If end of destination is not 64-bit aligned...</span>
<a name="l01037"></a>01037         if (!Test_align((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U64)))
<a name="l01038"></a>01038         {
<a name="l01039"></a>01039           <span class="comment">// Fill the end of the flash double-word buffer with the current flash page data.</span>
<a name="l01040"></a>01040           <span class="keywordflow">for</span> (; i &lt; <span class="keyword">sizeof</span>(U64); i++)
<a name="l01041"></a>01041             flash_dword.u8[i] = *tmp.u8ptr++;
<a name="l01042"></a>01042 
<a name="l01043"></a>01043           <span class="comment">// Write the flash double-word buffer to the page buffer.</span>
<a name="l01044"></a>01044           *dest.u64ptr++ = flash_dword.u64;
<a name="l01045"></a>01045         }
<a name="l01046"></a>01046 
<a name="l01047"></a>01047         <span class="comment">// Fill the end of the page buffer with the current flash page data.</span>
<a name="l01048"></a>01048         <span class="keywordflow">for</span> (; !Test_align((U32)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++)
<a name="l01049"></a>01049           *tmp.u64ptr = *tmp.u64ptr;
<a name="l01050"></a>01050       }
<a name="l01051"></a>01051     }
<a name="l01052"></a>01052 
<a name="l01053"></a>01053     <span class="comment">// If the current flash page is in the flash array...</span>
<a name="l01054"></a>01054     <span class="keywordflow">if</span> (dest.u8ptr &lt;= AVR32_FLASHC_USER_PAGE)
<a name="l01055"></a>01055     {
<a name="l01056"></a>01056       <span class="comment">// Erase the current page if requested and write it from the page buffer.</span>
<a name="l01057"></a>01057       <span class="keywordflow">if</span> (erase)
<a name="l01058"></a>01058       {
<a name="l01059"></a>01059         <a class="code" href="a00022.html#a8de3bbd50094f548ca293f07b136cc6d" title="Erases a page.">flashc_erase_page</a>(-1, <a class="code" href="a00021.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l01060"></a>01060         error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l01061"></a>01061       }
<a name="l01062"></a>01062       <a class="code" href="a00022.html#aa10438433246139bee71da6db2bb5bd5" title="Writes a page from the page buffer.">flashc_write_page</a>(-1);
<a name="l01063"></a>01063       error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l01064"></a>01064 
<a name="l01065"></a>01065       <span class="comment">// If the end of the flash array is reached, go to the User page.</span>
<a name="l01066"></a>01066       <span class="keywordflow">if</span> (dest.u8ptr &gt;= flash_array_end.u8ptr)
<a name="l01067"></a>01067       {
<a name="l01068"></a>01068         source.u8ptr += AVR32_FLASHC_USER_PAGE - dest.u8ptr;
<a name="l01069"></a>01069         dest.u8ptr = AVR32_FLASHC_USER_PAGE;
<a name="l01070"></a>01070       }
<a name="l01071"></a>01071     }
<a name="l01072"></a>01072     <span class="comment">// If the current flash page is the User page...</span>
<a name="l01073"></a>01073     <span class="keywordflow">else</span>
<a name="l01074"></a>01074     {
<a name="l01075"></a>01075       <span class="comment">// Erase the User page if requested and write it from the page buffer.</span>
<a name="l01076"></a>01076       <span class="keywordflow">if</span> (erase)
<a name="l01077"></a>01077       {
<a name="l01078"></a>01078         <a class="code" href="a00022.html#a2ef66c5ffa0974223c44e151a8719b6d" title="Erases the User page.">flashc_erase_user_page</a>(<a class="code" href="a00021.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l01079"></a>01079         error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l01080"></a>01080       }
<a name="l01081"></a>01081       <a class="code" href="a00022.html#ad04374b721dca9c534d7cd041ae24712" title="Writes the User page from the page buffer.">flashc_write_user_page</a>();
<a name="l01082"></a>01082       error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l01083"></a>01083     }
<a name="l01084"></a>01084   }
<a name="l01085"></a>01085 
<a name="l01086"></a>01086   <span class="comment">// Update the FLASHC error status.</span>
<a name="l01087"></a>01087   <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a> = error_status;
<a name="l01088"></a>01088 
<a name="l01089"></a>01089   <span class="comment">// Return the initial destination pointer as the standard memcpy function does.</span>
<a name="l01090"></a>01090   <span class="keywordflow">return</span> dst;
<a name="l01091"></a>01091 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a1e3ac5049d1eed492678764f8d1efc4b"></a><!-- doxytag: member="flashc.c::flashc_memset16" ref="a1e3ac5049d1eed492678764f8d1efc4b" args="(volatile void *dst, U16 src, size_t nbytes, Bool erase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile void* flashc_memset16 </td>
          <td>(</td>
          <td class="paramtype">volatile void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U16&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>erase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the repeated <em>src</em> big-endian source half-word. </p>
<p>The destination areas that are not within the flash array or the User page are ignored.</p>
<p>All pointer and size alignments are supported.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Pointer to flash destination. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Source half-word. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbytes</em>&nbsp;</td><td>Number of bytes to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>erase</em>&nbsp;</td><td>Whether to erase before writing: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of <em>dst</em>.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function may be called with <em>erase</em> set to <code>FALSE</code> only if the destination consists only of erased words, i.e. this function can not be used to write only one bit of a previously written word. E.g., if <code>0x00000001</code> then <code>0xFFFFFFFE</code> are written to a word, the resulting value in flash may be different from <code>0x00000000</code>.</dd>
<dd>
A Lock Error is issued if the command is applied to pages belonging to a locked region or to the bootloader protected area.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00701">701</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00707">flashc_memset32()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00695">flashc_memset8()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00702"></a>00702 {
<a name="l00703"></a>00703   <span class="keywordflow">return</span> <a class="code" href="a00022.html#af51102eac590a354c08f3b4311745674" title="Copies nbytes bytes to the flash destination pointed to by dst from the repeated...">flashc_memset32</a>(dst, src | (U32)src &lt;&lt; 16, nbytes, erase);
<a name="l00704"></a>00704 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="af51102eac590a354c08f3b4311745674"></a><!-- doxytag: member="flashc.c::flashc_memset32" ref="af51102eac590a354c08f3b4311745674" args="(volatile void *dst, U32 src, size_t nbytes, Bool erase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile void* flashc_memset32 </td>
          <td>(</td>
          <td class="paramtype">volatile void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U32&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>erase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the repeated <em>src</em> big-endian source word. </p>
<p>The destination areas that are not within the flash array or the User page are ignored.</p>
<p>All pointer and size alignments are supported.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Pointer to flash destination. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Source word. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbytes</em>&nbsp;</td><td>Number of bytes to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>erase</em>&nbsp;</td><td>Whether to erase before writing: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of <em>dst</em>.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function may be called with <em>erase</em> set to <code>FALSE</code> only if the destination consists only of erased words, i.e. this function can not be used to write only one bit of a previously written word. E.g., if <code>0x00000001</code> then <code>0xFFFFFFFE</code> are written to a word, the resulting value in flash may be different from <code>0x00000000</code>.</dd>
<dd>
A Lock Error is issued if the command is applied to pages belonging to a locked region or to the bootloader protected area.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00707">707</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00713">flashc_memset64()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00701">flashc_memset16()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00708"></a>00708 {
<a name="l00709"></a>00709   <span class="keywordflow">return</span> <a class="code" href="a00022.html#ad232684f65e596ffd85a63e0c1a5c41d" title="Copies nbytes bytes to the flash destination pointed to by dst from the repeated...">flashc_memset64</a>(dst, src | (U64)src &lt;&lt; 32, nbytes, erase);
<a name="l00710"></a>00710 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="ad232684f65e596ffd85a63e0c1a5c41d"></a><!-- doxytag: member="flashc.c::flashc_memset64" ref="ad232684f65e596ffd85a63e0c1a5c41d" args="(volatile void *dst, U64 src, size_t nbytes, Bool erase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile void* flashc_memset64 </td>
          <td>(</td>
          <td class="paramtype">volatile void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U64&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>erase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the repeated <em>src</em> big-endian source double-word. </p>
<p>The destination areas that are not within the flash array or the User page are ignored.</p>
<p>All pointer and size alignments are supported.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Pointer to flash destination. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Source double-word. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbytes</em>&nbsp;</td><td>Number of bytes to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>erase</em>&nbsp;</td><td>Whether to erase before writing: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of <em>dst</em>.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function may be called with <em>erase</em> set to <code>FALSE</code> only if the destination consists only of erased words, i.e. this function can not be used to write only one bit of a previously written word. E.g., if <code>0x00000001</code> then <code>0xFFFFFFFE</code> are written to a word, the resulting value in flash may be different from <code>0x00000000</code>.</dd>
<dd>
A Lock Error is issued if the command is applied to pages belonging to a locked region or to the bootloader protected area.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00713">713</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00021_source.html#l00360">FALSE</a>, <a class="el" href="a00022_source.html#l00621">flashc_clear_page_buffer()</a>, <a class="el" href="a00022_source.html#l00640">flashc_erase_page()</a>, <a class="el" href="a00022_source.html#l00682">flashc_erase_user_page()</a>, <a class="el" href="a00022_source.html#l00263">flashc_error_status</a>, <a class="el" href="a00022_source.html#l00078">flashc_get_flash_size()</a>, <a class="el" href="a00022_source.html#l00669">flashc_write_page()</a>, and <a class="el" href="a00022_source.html#l00689">flashc_write_user_page()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00707">flashc_memset32()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00714"></a>00714 {
<a name="l00715"></a>00715   <span class="comment">// Use aggregated pointers to have several alignments available for a same address.</span>
<a name="l00716"></a>00716   UnionCVPtr flash_array_end;
<a name="l00717"></a>00717   UnionVPtr dest;
<a name="l00718"></a>00718   Union64 source = {0};
<a name="l00719"></a>00719   StructCVPtr dest_end;
<a name="l00720"></a>00720   UnionCVPtr flash_page_source_end;
<a name="l00721"></a>00721   Bool incomplete_flash_page_end;
<a name="l00722"></a>00722   Union64 flash_dword;
<a name="l00723"></a>00723   UnionVPtr tmp;
<a name="l00724"></a>00724   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = 0;
<a name="l00725"></a>00725   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
<a name="l00726"></a>00726 
<a name="l00727"></a>00727   <span class="comment">// Reformat arguments.</span>
<a name="l00728"></a>00728   flash_array_end.u8ptr = AVR32_FLASH + <a class="code" href="a00022.html#a8071c315b02d038c49fa0bf89a40ba1b" title="Gets the size of the whole flash array.">flashc_get_flash_size</a>();
<a name="l00729"></a>00729   dest.u8ptr = dst;
<a name="l00730"></a>00730   <span class="keywordflow">for</span> (i = (Get_align((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64)) - 1) &amp; (<span class="keyword">sizeof</span>(U64) - 1);
<a name="l00731"></a>00731        src; i = (i - 1) &amp; (<span class="keyword">sizeof</span>(U64) - 1))
<a name="l00732"></a>00732   {
<a name="l00733"></a>00733     source.u8[i] = src;
<a name="l00734"></a>00734     src &gt;&gt;= 8;
<a name="l00735"></a>00735   }
<a name="l00736"></a>00736   dest_end.u8ptr = dest.u8ptr + nbytes;
<a name="l00737"></a>00737 
<a name="l00738"></a>00738   <span class="comment">// If destination is outside flash, go to next flash page if any.</span>
<a name="l00739"></a>00739   <span class="keywordflow">if</span> (dest.u8ptr &lt; AVR32_FLASH)
<a name="l00740"></a>00740   {
<a name="l00741"></a>00741     dest.u8ptr = AVR32_FLASH;
<a name="l00742"></a>00742   }
<a name="l00743"></a>00743   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (flash_array_end.u8ptr &lt;= dest.u8ptr &amp;&amp; dest.u8ptr &lt; AVR32_FLASHC_USER_PAGE)
<a name="l00744"></a>00744   {
<a name="l00745"></a>00745     dest.u8ptr = AVR32_FLASHC_USER_PAGE;
<a name="l00746"></a>00746   }
<a name="l00747"></a>00747 
<a name="l00748"></a>00748   <span class="comment">// If end of destination is outside flash, move it to the end of the previous flash page if any.</span>
<a name="l00749"></a>00749   <span class="keywordflow">if</span> (dest_end.u8ptr &gt; AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE)
<a name="l00750"></a>00750   {
<a name="l00751"></a>00751     dest_end.u8ptr = AVR32_FLASHC_USER_PAGE + AVR32_FLASHC_USER_PAGE_SIZE;
<a name="l00752"></a>00752   }
<a name="l00753"></a>00753   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (AVR32_FLASHC_USER_PAGE &gt;= dest_end.u8ptr &amp;&amp; dest_end.u8ptr &gt; flash_array_end.u8ptr)
<a name="l00754"></a>00754   {
<a name="l00755"></a>00755     dest_end.u8ptr = flash_array_end.u8ptr;
<a name="l00756"></a>00756   }
<a name="l00757"></a>00757 
<a name="l00758"></a>00758   <span class="comment">// Align each end of destination pointer with its natural boundary.</span>
<a name="l00759"></a>00759   dest_end.u16ptr = (U16 *)Align_down((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U16));
<a name="l00760"></a>00760   dest_end.u32ptr = (U32 *)Align_down((U32)dest_end.u16ptr, <span class="keyword">sizeof</span>(U32));
<a name="l00761"></a>00761   dest_end.u64ptr = (U64 *)Align_down((U32)dest_end.u32ptr, <span class="keyword">sizeof</span>(U64));
<a name="l00762"></a>00762 
<a name="l00763"></a>00763   <span class="comment">// While end of destination is not reached...</span>
<a name="l00764"></a>00764   <span class="keywordflow">while</span> (dest.u8ptr &lt; dest_end.u8ptr)
<a name="l00765"></a>00765   {
<a name="l00766"></a>00766     <span class="comment">// Clear the page buffer in order to prepare data for a flash page write.</span>
<a name="l00767"></a>00767     <a class="code" href="a00022.html#affafe9cb74731d817b721d2a52093412" title="Clears the page buffer.">flashc_clear_page_buffer</a>();
<a name="l00768"></a>00768     error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00769"></a>00769 
<a name="l00770"></a>00770     <span class="comment">// Determine where the source data will end in the current flash page.</span>
<a name="l00771"></a>00771     flash_page_source_end.u64ptr =
<a name="l00772"></a>00772       (U64 *)min((U32)dest_end.u64ptr,
<a name="l00773"></a>00773                  Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) + AVR32_FLASHC_PAGE_SIZE);
<a name="l00774"></a>00774 
<a name="l00775"></a>00775     <span class="comment">// Determine if the current destination page has an incomplete end.</span>
<a name="l00776"></a>00776     incomplete_flash_page_end = (Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE) &gt;=
<a name="l00777"></a>00777                                  Align_down((U32)dest_end.u8ptr, AVR32_FLASHC_PAGE_SIZE));
<a name="l00778"></a>00778 
<a name="l00779"></a>00779     <span class="comment">// Use a flash double-word buffer to manage unaligned accesses.</span>
<a name="l00780"></a>00780     flash_dword.u64 = source.u64;
<a name="l00781"></a>00781 
<a name="l00782"></a>00782     <span class="comment">// If destination does not point to the beginning of the current flash page...</span>
<a name="l00783"></a>00783     <span class="keywordflow">if</span> (!Test_align((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE))
<a name="l00784"></a>00784     {
<a name="l00785"></a>00785       <span class="comment">// Fill the beginning of the page buffer with the current flash page data.</span>
<a name="l00786"></a>00786       <span class="comment">// This is required by the hardware, even if page erase is not requested,</span>
<a name="l00787"></a>00787       <span class="comment">// in order to be able to write successfully to erased parts of flash</span>
<a name="l00788"></a>00788       <span class="comment">// pages that have already been written to.</span>
<a name="l00789"></a>00789       <span class="keywordflow">for</span> (tmp.u8ptr = (U8 *)Align_down((U32)dest.u8ptr, AVR32_FLASHC_PAGE_SIZE);
<a name="l00790"></a>00790            tmp.u64ptr &lt; (U64 *)Align_down((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64));
<a name="l00791"></a>00791            tmp.u64ptr++)
<a name="l00792"></a>00792         *tmp.u64ptr = *tmp.u64ptr;
<a name="l00793"></a>00793 
<a name="l00794"></a>00794       <span class="comment">// If destination is not 64-bit aligned...</span>
<a name="l00795"></a>00795       if (!Test_align((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64)))
<a name="l00796"></a>00796       {
<a name="l00797"></a>00797         <span class="comment">// Fill the beginning of the flash double-word buffer with the current</span>
<a name="l00798"></a>00798         <span class="comment">// flash page data.</span>
<a name="l00799"></a>00799         <span class="comment">// This is required by the hardware, even if page erase is not</span>
<a name="l00800"></a>00800         <span class="comment">// requested, in order to be able to write successfully to erased parts</span>
<a name="l00801"></a>00801         <span class="comment">// of flash pages that have already been written to.</span>
<a name="l00802"></a>00802         <span class="keywordflow">for</span> (i = 0; i &lt; Get_align((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64)); i++)
<a name="l00803"></a>00803           flash_dword.u8[i] = *tmp.u8ptr++;
<a name="l00804"></a>00804 
<a name="l00805"></a>00805         <span class="comment">// Align the destination pointer with its 64-bit boundary.</span>
<a name="l00806"></a>00806         dest.u64ptr = (U64 *)Align_down((U32)dest.u8ptr, <span class="keyword">sizeof</span>(U64));
<a name="l00807"></a>00807 
<a name="l00808"></a>00808         <span class="comment">// If the current destination double-word is not the last one...</span>
<a name="l00809"></a>00809         <span class="keywordflow">if</span> (dest.u64ptr &lt; dest_end.u64ptr)
<a name="l00810"></a>00810         {
<a name="l00811"></a>00811           <span class="comment">// Write the flash double-word buffer to the page buffer and reinitialize it.</span>
<a name="l00812"></a>00812           *dest.u64ptr++ = flash_dword.u64;
<a name="l00813"></a>00813           flash_dword.u64 = source.u64;
<a name="l00814"></a>00814         }
<a name="l00815"></a>00815       }
<a name="l00816"></a>00816     }
<a name="l00817"></a>00817 
<a name="l00818"></a>00818     <span class="comment">// Write the source data to the page buffer with 64-bit alignment.</span>
<a name="l00819"></a>00819     <span class="keywordflow">for</span> (i = flash_page_source_end.u64ptr - dest.u64ptr; i; i--)
<a name="l00820"></a>00820       *dest.u64ptr++ = source.u64;
<a name="l00821"></a>00821 
<a name="l00822"></a>00822     <span class="comment">// If the current destination page has an incomplete end...</span>
<a name="l00823"></a>00823     <span class="keywordflow">if</span> (incomplete_flash_page_end)
<a name="l00824"></a>00824     {
<a name="l00825"></a>00825       <span class="comment">// This is required by the hardware, even if page erase is not requested,</span>
<a name="l00826"></a>00826       <span class="comment">// in order to be able to write successfully to erased parts of flash</span>
<a name="l00827"></a>00827       <span class="comment">// pages that have already been written to.</span>
<a name="l00828"></a>00828       {
<a name="l00829"></a>00829         tmp.u8ptr = (<span class="keyword">volatile</span> U8 *)dest_end.u8ptr;
<a name="l00830"></a>00830 
<a name="l00831"></a>00831         <span class="comment">// If end of destination is not 64-bit aligned...</span>
<a name="l00832"></a>00832         if (!Test_align((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U64)))
<a name="l00833"></a>00833         {
<a name="l00834"></a>00834           <span class="comment">// Fill the end of the flash double-word buffer with the current flash page data.</span>
<a name="l00835"></a>00835           <span class="keywordflow">for</span> (i = Get_align((U32)dest_end.u8ptr, <span class="keyword">sizeof</span>(U64)); i &lt; <span class="keyword">sizeof</span>(U64); i++)
<a name="l00836"></a>00836             flash_dword.u8[i] = *tmp.u8ptr++;
<a name="l00837"></a>00837 
<a name="l00838"></a>00838           <span class="comment">// Write the flash double-word buffer to the page buffer.</span>
<a name="l00839"></a>00839           *dest.u64ptr++ = flash_dword.u64;
<a name="l00840"></a>00840         }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842         <span class="comment">// Fill the end of the page buffer with the current flash page data.</span>
<a name="l00843"></a>00843         <span class="keywordflow">for</span> (; !Test_align((U32)tmp.u64ptr, AVR32_FLASHC_PAGE_SIZE); tmp.u64ptr++)
<a name="l00844"></a>00844           *tmp.u64ptr = *tmp.u64ptr;
<a name="l00845"></a>00845       }
<a name="l00846"></a>00846     }
<a name="l00847"></a>00847 
<a name="l00848"></a>00848     <span class="comment">// If the current flash page is in the flash array...</span>
<a name="l00849"></a>00849     <span class="keywordflow">if</span> (dest.u8ptr &lt;= AVR32_FLASHC_USER_PAGE)
<a name="l00850"></a>00850     {
<a name="l00851"></a>00851       <span class="comment">// Erase the current page if requested and write it from the page buffer.</span>
<a name="l00852"></a>00852       <span class="keywordflow">if</span> (erase)
<a name="l00853"></a>00853       {
<a name="l00854"></a>00854         <a class="code" href="a00022.html#a8de3bbd50094f548ca293f07b136cc6d" title="Erases a page.">flashc_erase_page</a>(-1, <a class="code" href="a00021.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l00855"></a>00855         error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00856"></a>00856       }
<a name="l00857"></a>00857       <a class="code" href="a00022.html#aa10438433246139bee71da6db2bb5bd5" title="Writes a page from the page buffer.">flashc_write_page</a>(-1);
<a name="l00858"></a>00858       error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00859"></a>00859 
<a name="l00860"></a>00860       <span class="comment">// If the end of the flash array is reached, go to the User page.</span>
<a name="l00861"></a>00861       <span class="keywordflow">if</span> (dest.u8ptr &gt;= flash_array_end.u8ptr)
<a name="l00862"></a>00862         dest.u8ptr = AVR32_FLASHC_USER_PAGE;
<a name="l00863"></a>00863     }
<a name="l00864"></a>00864     <span class="comment">// If the current flash page is the User page...</span>
<a name="l00865"></a>00865     <span class="keywordflow">else</span>
<a name="l00866"></a>00866     {
<a name="l00867"></a>00867       <span class="comment">// Erase the User page if requested and write it from the page buffer.</span>
<a name="l00868"></a>00868       <span class="keywordflow">if</span> (erase)
<a name="l00869"></a>00869       {
<a name="l00870"></a>00870         <a class="code" href="a00022.html#a2ef66c5ffa0974223c44e151a8719b6d" title="Erases the User page.">flashc_erase_user_page</a>(<a class="code" href="a00021.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l00871"></a>00871         error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00872"></a>00872       }
<a name="l00873"></a>00873       <a class="code" href="a00022.html#ad04374b721dca9c534d7cd041ae24712" title="Writes the User page from the page buffer.">flashc_write_user_page</a>();
<a name="l00874"></a>00874       error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00875"></a>00875     }
<a name="l00876"></a>00876   }
<a name="l00877"></a>00877 
<a name="l00878"></a>00878   <span class="comment">// Update the FLASHC error status.</span>
<a name="l00879"></a>00879   <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a> = error_status;
<a name="l00880"></a>00880 
<a name="l00881"></a>00881   <span class="comment">// Return the initial destination pointer as the standard memset function does.</span>
<a name="l00882"></a>00882   <span class="keywordflow">return</span> dst;
<a name="l00883"></a>00883 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="acc5c426d84ce1ef1d2e898e827b23207"></a><!-- doxytag: member="flashc.c::flashc_memset8" ref="acc5c426d84ce1ef1d2e898e827b23207" args="(volatile void *dst, U8 src, size_t nbytes, Bool erase)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile void* flashc_memset8 </td>
          <td>(</td>
          <td class="paramtype">volatile void *&nbsp;</td>
          <td class="paramname"> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>nbytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>erase</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies <em>nbytes</em> bytes to the flash destination pointed to by <em>dst</em> from the repeated <em>src</em> source byte. </p>
<p>The destination areas that are not within the flash array or the User page are ignored.</p>
<p>All pointer and size alignments are supported.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>dst</em>&nbsp;</td><td>Pointer to flash destination. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>src</em>&nbsp;</td><td>Source byte. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nbytes</em>&nbsp;</td><td>Number of bytes to set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>erase</em>&nbsp;</td><td>Whether to erase before writing: <code>TRUE</code> or <code>FALSE</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of <em>dst</em>.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>This function may be called with <em>erase</em> set to <code>FALSE</code> only if the destination consists only of erased words, i.e. this function can not be used to write only one bit of a previously written word. E.g., if <code>0x00000001</code> then <code>0xFFFFFFFE</code> are written to a word, the resulting value in flash may be different from <code>0x00000000</code>.</dd>
<dd>
A Lock Error is issued if the command is applied to pages belonging to a locked region or to the bootloader protected area.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00695">695</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00701">flashc_memset16()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00696"></a>00696 {
<a name="l00697"></a>00697   <span class="keywordflow">return</span> <a class="code" href="a00022.html#a1e3ac5049d1eed492678764f8d1efc4b" title="Copies nbytes bytes to the flash destination pointed to by dst from the repeated...">flashc_memset16</a>(dst, src | (U16)src &lt;&lt; 8, nbytes, erase);
<a name="l00698"></a>00698 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="aac955da1ba0b0833d17d3068c34222ec"></a><!-- doxytag: member="flashc.c::flashc_no_operation" ref="aac955da1ba0b0833d17d3068c34222ec" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_no_operation </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Issues a No Operation command to the FLASHC. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00320">320</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00321"></a>00321 {
<a name="l00322"></a>00322   <a class="code" href="a00022.html#a8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_NOP, -1);
<a name="l00323"></a>00323 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="acd50527aacf1d9ae11608fcc49a4fdcf"></a><!-- doxytag: member="flashc.c::flashc_quick_page_read" ref="acd50527aacf1d9ae11608fcc49a4fdcf" args="(int page_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_quick_page_read </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page_number</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Applies the Quick Page Read command to a page. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_number</em>&nbsp;</td><td>The page number: </p>
<ul>
<li><code>0</code> to <code>(<a class="el" href="a00022.html#aafad0dcf645cc65acb5bc879558dac23" title="Gets the total number of pages in the flash array.">flashc_get_page_count()</a> - 1)</code>: a page number within the flash array; </li>
<li><code>&lt; 0</code>: the current page number.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the specified page is erased.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00633">633</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00627">flashc_is_page_erased()</a>, and <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00640">flashc_erase_page()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00634"></a>00634 {
<a name="l00635"></a>00635   <a class="code" href="a00022.html#a8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_QPR, page_number);
<a name="l00636"></a>00636   <span class="keywordflow">return</span> <a class="code" href="a00022.html#acdea4bfb0cb1066fba239a9302196ee5" title="Tells whether the page to which the last Quick Page Read or Quick Page Read User...">flashc_is_page_erased</a>();
<a name="l00637"></a>00637 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a4cdef3bd6e4b7da53e4b7b7dc1adcd2f"></a><!-- doxytag: member="flashc.c::flashc_quick_user_page_read" ref="a4cdef3bd6e4b7da53e4b7b7dc1adcd2f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_quick_user_page_read </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Issues a Quick Page Read User Page command to the FLASHC. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Whether the User page is erased.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00675">675</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00627">flashc_is_page_erased()</a>, and <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00682">flashc_erase_user_page()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00676"></a>00676 {
<a name="l00677"></a>00677   <a class="code" href="a00022.html#a8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_QPRUP, -1);
<a name="l00678"></a>00678   <span class="keywordflow">return</span> <a class="code" href="a00022.html#acdea4bfb0cb1066fba239a9302196ee5" title="Tells whether the page to which the last Quick Page Read or Quick Page Read User...">flashc_is_page_erased</a>();
<a name="l00679"></a>00679 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a08124caa02942b5fa1d370a81a84dfb5"></a><!-- doxytag: member="flashc.c::flashc_read_all_gp_fuses" ref="a08124caa02942b5fa1d370a81a84dfb5" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U64 flashc_read_all_gp_fuses </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads all general-purpose fuses. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of all general-purpose fuses as a word.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The actual number of general-purpose fuse bits implemented by hardware is given by <code>AVR32_FLASHC_GPF_NUM</code>. The other bits among the 64 are fixed at 1 by hardware. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00452">452</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00501">flashc_erase_all_gp_fuses()</a>, <a class="el" href="a00022_source.html#l00481">flashc_erase_gp_fuse_byte()</a>, <a class="el" href="a00022_source.html#l00434">flashc_read_gp_fuse_bit()</a>, <a class="el" href="a00022_source.html#l00440">flashc_read_gp_fuse_bitfield()</a>, and <a class="el" href="a00022_source.html#l00446">flashc_read_gp_fuse_byte()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00453"></a>00453 {
<a name="l00454"></a>00454   <span class="keywordflow">return</span> AVR32_FLASHC.fgpfrlo | (U64)AVR32_FLASHC.fgpfrhi &lt;&lt; 32;
<a name="l00455"></a>00455 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="ae6203d2e69ff15d59366c28bf8e26a7e"></a><!-- doxytag: member="flashc.c::flashc_read_gp_fuse_bit" ref="ae6203d2e69ff15d59366c28bf8e26a7e" args="(unsigned int gp_fuse_bit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Bool flashc_read_gp_fuse_bit </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gp_fuse_bit</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a general-purpose fuse bit. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gp_fuse_bit</em>&nbsp;</td><td>The general-purpose fuse bit: <code>0</code> to <code>63</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the specified general-purpose fuse bit.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The actual number of general-purpose fuse bits implemented by hardware is given by <code>AVR32_FLASHC_GPF_NUM</code>. The other bits among the 64 are fixed at 1 by hardware. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00434">434</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00452">flashc_read_all_gp_fuses()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00458">flashc_erase_gp_fuse_bit()</a>, and <a class="el" href="a00022_source.html#l00377">flashc_is_external_privileged_fetch_locked()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00435"></a>00435 {
<a name="l00436"></a>00436   <span class="keywordflow">return</span> ((<a class="code" href="a00022.html#a08124caa02942b5fa1d370a81a84dfb5" title="Reads all general-purpose fuses.">flashc_read_all_gp_fuses</a>() &amp; 1ULL &lt;&lt; (gp_fuse_bit &amp; 0x3F)) != 0);
<a name="l00437"></a>00437 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a0a0ce2691a31e0d529ec1143d61c4a86"></a><!-- doxytag: member="flashc.c::flashc_read_gp_fuse_bitfield" ref="a0a0ce2691a31e0d529ec1143d61c4a86" args="(unsigned int pos, unsigned int width)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U64 flashc_read_gp_fuse_bitfield </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>width</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a general-purpose fuse bit-field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The bit-position of the general-purpose fuse bit-field: <code>0</code> to <code>63</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The bit-width of the general-purpose fuse bit-field: <code>0</code> to <code>64</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the specified general-purpose fuse bit-field.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The actual number of general-purpose fuse bits implemented by hardware is given by <code>AVR32_FLASHC_GPF_NUM</code>. The other bits among the 64 are fixed at 1 by hardware. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00440">440</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00452">flashc_read_all_gp_fuses()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00465">flashc_erase_gp_fuse_bitfield()</a>, and <a class="el" href="a00022_source.html#l00352">flashc_get_bootloader_protected_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00441"></a>00441 {
<a name="l00442"></a>00442   <span class="keywordflow">return</span> <a class="code" href="a00022.html#a08124caa02942b5fa1d370a81a84dfb5" title="Reads all general-purpose fuses.">flashc_read_all_gp_fuses</a>() &gt;&gt; (pos &amp; 0x3F) &amp; ((1ULL &lt;&lt; min(width, 64)) - 1);
<a name="l00443"></a>00443 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a1ad2aab294e528795bbd835539b0b14e"></a><!-- doxytag: member="flashc.c::flashc_read_gp_fuse_byte" ref="a1ad2aab294e528795bbd835539b0b14e" args="(unsigned int gp_fuse_byte)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">U8 flashc_read_gp_fuse_byte </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gp_fuse_byte</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reads a general-purpose fuse byte. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gp_fuse_byte</em>&nbsp;</td><td>The general-purpose fuse byte: <code>0</code> to <code>7</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The value of the specified general-purpose fuse byte.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The actual number of general-purpose fuse bits implemented by hardware is given by <code>AVR32_FLASHC_GPF_NUM</code>. The other bits among the 64 are fixed at 1 by hardware. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00446">446</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00452">flashc_read_all_gp_fuses()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00481">flashc_erase_gp_fuse_byte()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00447"></a>00447 {
<a name="l00448"></a>00448   <span class="keywordflow">return</span> <a class="code" href="a00022.html#a08124caa02942b5fa1d370a81a84dfb5" title="Reads all general-purpose fuses.">flashc_read_all_gp_fuses</a>() &gt;&gt; ((gp_fuse_byte &amp; 0x07) &lt;&lt; 3);
<a name="l00449"></a>00449 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="ac00d0edaa152b6d107c5cdb9350ba97d"></a><!-- doxytag: member="flashc.c::flashc_set_all_gp_fuses" ref="ac00d0edaa152b6d107c5cdb9350ba97d" args="(U64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_set_all_gp_fuses </td>
          <td>(</td>
          <td class="paramtype">U64&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets all general-purpose fuses with the appropriate erase and write operations. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of all general-purpose fuses as a word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
The actual number of general-purpose fuse bits implemented by hardware is given by <code>AVR32_FLASHC_GPF_NUM</code>. The other bits among the 64 are fixed at 1 by hardware. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00593">593</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00021_source.html#l00360">FALSE</a>, <a class="el" href="a00022_source.html#l00501">flashc_erase_all_gp_fuses()</a>, <a class="el" href="a00022_source.html#l00263">flashc_error_status</a>, and <a class="el" href="a00022_source.html#l00536">flashc_write_all_gp_fuses()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00594"></a>00594 {
<a name="l00595"></a>00595   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status;
<a name="l00596"></a>00596   <span class="keywordflow">switch</span> (value)
<a name="l00597"></a>00597   {
<a name="l00598"></a>00598   <span class="keywordflow">case</span> 0xFFFFFFFFFFFFFFFFULL:
<a name="l00599"></a>00599     <a class="code" href="a00022.html#acf3096dc9ecea92533c4688d7f90a0ef" title="Erases all general-purpose fuses.">flashc_erase_all_gp_fuses</a>(<a class="code" href="a00021.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l00600"></a>00600     <span class="keywordflow">break</span>;
<a name="l00601"></a>00601   <span class="keywordflow">case</span> 0x0000000000000000ULL:
<a name="l00602"></a>00602     <a class="code" href="a00022.html#a408609845a9b3de37bf9307076d851d6" title="Writes all general-purpose fuses.">flashc_write_all_gp_fuses</a>(0x0000000000000000ULL);
<a name="l00603"></a>00603     <span class="keywordflow">break</span>;
<a name="l00604"></a>00604   <span class="keywordflow">default</span>:
<a name="l00605"></a>00605     <a class="code" href="a00022.html#acf3096dc9ecea92533c4688d7f90a0ef" title="Erases all general-purpose fuses.">flashc_erase_all_gp_fuses</a>(<a class="code" href="a00021.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l00606"></a>00606     error_status = <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00607"></a>00607     <a class="code" href="a00022.html#a408609845a9b3de37bf9307076d851d6" title="Writes all general-purpose fuses.">flashc_write_all_gp_fuses</a>(value);
<a name="l00608"></a>00608     <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a> |= error_status;
<a name="l00609"></a>00609   }
<a name="l00610"></a>00610 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a076a1b22c9f3e6dad1739f0398f89b37"></a><!-- doxytag: member="flashc.c::flashc_set_bootloader_protected_size" ref="a076a1b22c9f3e6dad1739f0398f89b37" args="(unsigned int bootprot_size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int flashc_set_bootloader_protected_size </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>bootprot_size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the bootloader protected size. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bootprot_size</em>&nbsp;</td><td>The wanted bootloader protected size in bytes. If this size is not supported, the actual size will be the nearest greater available size or the maximal possible size if the requested size is too large.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The actual bootloader protected size in bytes.</dd></dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00361">361</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00352">flashc_get_bootloader_protected_size()</a>, and <a class="el" href="a00022_source.html#l00558">flashc_set_gp_fuse_bitfield()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00362"></a>00362 {
<a name="l00363"></a>00363   <a class="code" href="a00022.html#a8969b973563adb568121db44768a2246" title="Sets a general-purpose fuse bit-field with the appropriate erase and write operations...">flashc_set_gp_fuse_bitfield</a>(AVR32_FLASHC_FGPFRLO_BOOTPROT_OFFSET,
<a name="l00364"></a>00364                               AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE,
<a name="l00365"></a>00365                               (1 &lt;&lt; AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE) - 1 -
<a name="l00366"></a>00366                               ((bootprot_size) ?
<a name="l00367"></a>00367                                32 - clz((((min(max(bootprot_size, AVR32_FLASHC_PAGE_SIZE &lt;&lt; 1),
<a name="l00368"></a>00368                                                AVR32_FLASHC_PAGE_SIZE &lt;&lt;
<a name="l00369"></a>00369                                                ((1 &lt;&lt; AVR32_FLASHC_FGPFRLO_BOOTPROT_SIZE) - 1)) +
<a name="l00370"></a>00370                                            AVR32_FLASHC_PAGE_SIZE - 1) /
<a name="l00371"></a>00371                                           AVR32_FLASHC_PAGE_SIZE) &lt;&lt; 1) - 1) - 1 :
<a name="l00372"></a>00372                                0));
<a name="l00373"></a>00373   <span class="keywordflow">return</span> <a class="code" href="a00022.html#a83ed88a41076163bd29ca80d30cb094f" title="Gets the bootloader protected size.">flashc_get_bootloader_protected_size</a>();
<a name="l00374"></a>00374 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a5dda977da7d7381b125b2fa25ef9ae90"></a><!-- doxytag: member="flashc.c::flashc_set_bus_freq" ref="a5dda977da7d7381b125b2fa25ef9ae90" args="(unsigned int cpu_f_hz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_set_bus_freq </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>cpu_f_hz</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Depending on the CPU frequency, set the wait states of flash read accesses. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cpu_f_hz</em>&nbsp;</td><td>The CPU frequency </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00163">163</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00155">flashc_set_wait_state()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00164"></a>00164 {
<a name="l00165"></a>00165   <span class="keywordflow">if</span>(cpu_f_hz &gt;= AVR32_FLASHC_FWS_0_MAX_FREQ)
<a name="l00166"></a>00166   {
<a name="l00167"></a>00167     <span class="comment">// Set 1 WS.</span>
<a name="l00168"></a>00168     <a class="code" href="a00022.html#a2835c7ef58f410290ad530d34d7e8133" title="Sets the number of wait states of flash read accesses.">flashc_set_wait_state</a>(1);
<a name="l00169"></a>00169   }
<a name="l00170"></a>00170   <span class="keywordflow">else</span>
<a name="l00171"></a>00171   {
<a name="l00172"></a>00172     <span class="comment">// Set 0 WS.</span>
<a name="l00173"></a>00173     <a class="code" href="a00022.html#a2835c7ef58f410290ad530d34d7e8133" title="Sets the number of wait states of flash read accesses.">flashc_set_wait_state</a>(0);
<a name="l00174"></a>00174   }
<a name="l00175"></a>00175 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a5c5442a988c608baea0d1c0b841badca"></a><!-- doxytag: member="flashc.c::flashc_set_gp_fuse_bit" ref="a5c5442a988c608baea0d1c0b841badca" args="(unsigned int gp_fuse_bit, Bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_set_gp_fuse_bit </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gp_fuse_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a general-purpose fuse bit with the appropriate erase and write operations. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gp_fuse_bit</em>&nbsp;</td><td>The general-purpose fuse bit: <code>0</code> to <code>63</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the specified general-purpose fuse bit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active and the command is applied to BOOTPROT or EPFL fuses.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
The actual number of general-purpose fuse bits implemented by hardware is given by <code>AVR32_FLASHC_GPF_NUM</code>. The other bits among the 64 are fixed at 1 by hardware. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00549">549</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00021_source.html#l00360">FALSE</a>, <a class="el" href="a00022_source.html#l00458">flashc_erase_gp_fuse_bit()</a>, and <a class="el" href="a00022_source.html#l00508">flashc_write_gp_fuse_bit()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00383">flashc_lock_external_privileged_fetch()</a>, and <a class="el" href="a00022_source.html#l00558">flashc_set_gp_fuse_bitfield()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00550"></a>00550 {
<a name="l00551"></a>00551   <span class="keywordflow">if</span> (value)
<a name="l00552"></a>00552     <a class="code" href="a00022.html#a3d3494ba9bfe90893f65d2d3d90ab088" title="Erases a general-purpose fuse bit.">flashc_erase_gp_fuse_bit</a>(gp_fuse_bit, <a class="code" href="a00021.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l00553"></a>00553   <span class="keywordflow">else</span>
<a name="l00554"></a>00554     <a class="code" href="a00022.html#a52f9456a7effcc28290c3139f7d54bfc" title="Writes a general-purpose fuse bit.">flashc_write_gp_fuse_bit</a>(gp_fuse_bit, <a class="code" href="a00021.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l00555"></a>00555 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a8969b973563adb568121db44768a2246"></a><!-- doxytag: member="flashc.c::flashc_set_gp_fuse_bitfield" ref="a8969b973563adb568121db44768a2246" args="(unsigned int pos, unsigned int width, U64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_set_gp_fuse_bitfield </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U64&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a general-purpose fuse bit-field with the appropriate erase and write operations. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The bit-position of the general-purpose fuse bit-field: <code>0</code> to <code>63</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The bit-width of the general-purpose fuse bit-field: <code>0</code> to <code>64</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the specified general-purpose fuse bit-field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active and the command is applied to BOOTPROT or EPFL fuses.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
The actual number of general-purpose fuse bits implemented by hardware is given by <code>AVR32_FLASHC_GPF_NUM</code>. The other bits among the 64 are fixed at 1 by hardware. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00558">558</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00263">flashc_error_status</a>, and <a class="el" href="a00022_source.html#l00549">flashc_set_gp_fuse_bit()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00361">flashc_set_bootloader_protected_size()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00559"></a>00559 {
<a name="l00560"></a>00560   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = 0;
<a name="l00561"></a>00561   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gp_fuse_bit;
<a name="l00562"></a>00562   pos &amp;= 0x3F;
<a name="l00563"></a>00563   width = min(width, 64);
<a name="l00564"></a>00564   <span class="keywordflow">for</span> (gp_fuse_bit = pos; gp_fuse_bit &lt; pos + width; gp_fuse_bit++, value &gt;&gt;= 1)
<a name="l00565"></a>00565   {
<a name="l00566"></a>00566     <a class="code" href="a00022.html#a5c5442a988c608baea0d1c0b841badca" title="Sets a general-purpose fuse bit with the appropriate erase and write operations.">flashc_set_gp_fuse_bit</a>(gp_fuse_bit, value &amp; 0x01);
<a name="l00567"></a>00567     error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00568"></a>00568   }
<a name="l00569"></a>00569   <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a> = error_status;
<a name="l00570"></a>00570 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="acda1125f62193f69c24c0e4975e95b4d"></a><!-- doxytag: member="flashc.c::flashc_set_gp_fuse_byte" ref="acda1125f62193f69c24c0e4975e95b4d" args="(unsigned int gp_fuse_byte, U8 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_set_gp_fuse_byte </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gp_fuse_byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a general-purpose fuse byte with the appropriate erase and write operations. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gp_fuse_byte</em>&nbsp;</td><td>The general-purpose fuse byte: <code>0</code> to <code>7</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the specified general-purpose fuse byte.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
The actual number of general-purpose fuse bits implemented by hardware is given by <code>AVR32_FLASHC_GPF_NUM</code>. The other bits among the 64 are fixed at 1 by hardware. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00573">573</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00021_source.html#l00360">FALSE</a>, <a class="el" href="a00022_source.html#l00481">flashc_erase_gp_fuse_byte()</a>, <a class="el" href="a00022_source.html#l00263">flashc_error_status</a>, and <a class="el" href="a00022_source.html#l00530">flashc_write_gp_fuse_byte()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00574"></a>00574 {
<a name="l00575"></a>00575   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status;
<a name="l00576"></a>00576   <span class="keywordflow">switch</span> (value)
<a name="l00577"></a>00577   {
<a name="l00578"></a>00578   <span class="keywordflow">case</span> 0xFF:
<a name="l00579"></a>00579     <a class="code" href="a00022.html#a293468b5d263ffe7f9a2595c900a9293" title="Erases a general-purpose fuse byte.">flashc_erase_gp_fuse_byte</a>(gp_fuse_byte, <a class="code" href="a00021.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l00580"></a>00580     <span class="keywordflow">break</span>;
<a name="l00581"></a>00581   <span class="keywordflow">case</span> 0x00:
<a name="l00582"></a>00582     <a class="code" href="a00022.html#a7670e69d41fe6a985ad898be25044caf" title="Writes a general-purpose fuse byte.">flashc_write_gp_fuse_byte</a>(gp_fuse_byte, 0x00);
<a name="l00583"></a>00583     <span class="keywordflow">break</span>;
<a name="l00584"></a>00584   <span class="keywordflow">default</span>:
<a name="l00585"></a>00585     <a class="code" href="a00022.html#a293468b5d263ffe7f9a2595c900a9293" title="Erases a general-purpose fuse byte.">flashc_erase_gp_fuse_byte</a>(gp_fuse_byte, <a class="code" href="a00021.html#aa93f0eb578d23995850d61f7d61c55c1">FALSE</a>);
<a name="l00586"></a>00586     error_status = <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00587"></a>00587     <a class="code" href="a00022.html#a7670e69d41fe6a985ad898be25044caf" title="Writes a general-purpose fuse byte.">flashc_write_gp_fuse_byte</a>(gp_fuse_byte, value);
<a name="l00588"></a>00588     <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a> |= error_status;
<a name="l00589"></a>00589   }
<a name="l00590"></a>00590 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a2835c7ef58f410290ad530d34d7e8133"></a><!-- doxytag: member="flashc.c::flashc_set_wait_state" ref="a2835c7ef58f410290ad530d34d7e8133" args="(unsigned int wait_state)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_set_wait_state </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>wait_state</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the number of wait states of flash read accesses. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>wait_state</em>&nbsp;</td><td>The number of wait states of flash read accesses: <code>0</code> to <code>1</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00155">155</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00060">u_avr32_flashc_fcr_t::fcr</a>, and <a class="el" href="a00022_source.html#l00061">u_avr32_flashc_fcr_t::FCR</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00163">flashc_set_bus_freq()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00156"></a>00156 {
<a name="l00157"></a>00157   <a class="code" href="a00011.html">u_avr32_flashc_fcr_t</a> u_avr32_flashc_fcr = {AVR32_FLASHC.fcr};
<a name="l00158"></a>00158   u_avr32_flashc_fcr.<a class="code" href="a00011.html#aa8f3a48553db579f2272c10a5ad2c710">FCR</a>.fws = wait_state;
<a name="l00159"></a>00159   AVR32_FLASHC.fcr = u_avr32_flashc_fcr.<a class="code" href="a00011.html#a4931f45cdf8856a36fd6670033cfbe99">fcr</a>;
<a name="l00160"></a>00160 }
</pre></div></p>

</div>
</div>
<a class="anchor" id="a408609845a9b3de37bf9307076d851d6"></a><!-- doxytag: member="flashc.c::flashc_write_all_gp_fuses" ref="a408609845a9b3de37bf9307076d851d6" args="(U64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_write_all_gp_fuses </td>
          <td>(</td>
          <td class="paramtype">U64&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes all general-purpose fuses. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of all general-purpose fuses as a word.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
A write operation can only clear bits.</dd>
<dd>
The actual number of general-purpose fuse bits implemented by hardware is given by <code>AVR32_FLASHC_GPF_NUM</code>. The other bits among the 64 are fixed at 1 by hardware. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00536">536</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00263">flashc_error_status</a>, and <a class="el" href="a00022_source.html#l00530">flashc_write_gp_fuse_byte()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00593">flashc_set_all_gp_fuses()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00537"></a>00537 {
<a name="l00538"></a>00538   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = 0;
<a name="l00539"></a>00539   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gp_fuse_byte;
<a name="l00540"></a>00540   <span class="keywordflow">for</span> (gp_fuse_byte = 0; gp_fuse_byte &lt; 8; gp_fuse_byte++, value &gt;&gt;= 8)
<a name="l00541"></a>00541   {
<a name="l00542"></a>00542     <a class="code" href="a00022.html#a7670e69d41fe6a985ad898be25044caf" title="Writes a general-purpose fuse byte.">flashc_write_gp_fuse_byte</a>(gp_fuse_byte, value);
<a name="l00543"></a>00543     error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00544"></a>00544   }
<a name="l00545"></a>00545   <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a> = error_status;
<a name="l00546"></a>00546 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a52f9456a7effcc28290c3139f7d54bfc"></a><!-- doxytag: member="flashc.c::flashc_write_gp_fuse_bit" ref="a52f9456a7effcc28290c3139f7d54bfc" args="(unsigned int gp_fuse_bit, Bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_write_gp_fuse_bit </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gp_fuse_bit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a general-purpose fuse bit. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gp_fuse_bit</em>&nbsp;</td><td>The general-purpose fuse bit: <code>0</code> to <code>63</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the specified general-purpose fuse bit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active and the command is applied to BOOTPROT or EPFL fuses.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
A write operation can only clear bits.</dd>
<dd>
The actual number of general-purpose fuse bits implemented by hardware is given by <code>AVR32_FLASHC_GPF_NUM</code>. The other bits among the 64 are fixed at 1 by hardware. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00508">508</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00549">flashc_set_gp_fuse_bit()</a>, and <a class="el" href="a00022_source.html#l00515">flashc_write_gp_fuse_bitfield()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00509"></a>00509 {
<a name="l00510"></a>00510   <span class="keywordflow">if</span> (!value)
<a name="l00511"></a>00511     <a class="code" href="a00022.html#a8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_WGPB, gp_fuse_bit &amp; 0x3F);
<a name="l00512"></a>00512 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a018e2f6ca164ef9b9d680de53cf08739"></a><!-- doxytag: member="flashc.c::flashc_write_gp_fuse_bitfield" ref="a018e2f6ca164ef9b9d680de53cf08739" args="(unsigned int pos, unsigned int width, U64 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_write_gp_fuse_bitfield </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U64&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a general-purpose fuse bit-field. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pos</em>&nbsp;</td><td>The bit-position of the general-purpose fuse bit-field: <code>0</code> to <code>63</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>width</em>&nbsp;</td><td>The bit-width of the general-purpose fuse bit-field: <code>0</code> to <code>64</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the specified general-purpose fuse bit-field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active and the command is applied to BOOTPROT or EPFL fuses.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
A write operation can only clear bits.</dd>
<dd>
The actual number of general-purpose fuse bits implemented by hardware is given by <code>AVR32_FLASHC_GPF_NUM</code>. The other bits among the 64 are fixed at 1 by hardware. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00515">515</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00263">flashc_error_status</a>, and <a class="el" href="a00022_source.html#l00508">flashc_write_gp_fuse_bit()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00516"></a>00516 {
<a name="l00517"></a>00517   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> error_status = 0;
<a name="l00518"></a>00518   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gp_fuse_bit;
<a name="l00519"></a>00519   pos &amp;= 0x3F;
<a name="l00520"></a>00520   width = min(width, 64);
<a name="l00521"></a>00521   <span class="keywordflow">for</span> (gp_fuse_bit = pos; gp_fuse_bit &lt; pos + width; gp_fuse_bit++, value &gt;&gt;= 1)
<a name="l00522"></a>00522   {
<a name="l00523"></a>00523     <a class="code" href="a00022.html#a52f9456a7effcc28290c3139f7d54bfc" title="Writes a general-purpose fuse bit.">flashc_write_gp_fuse_bit</a>(gp_fuse_bit, value &amp; 0x01);
<a name="l00524"></a>00524     error_status |= <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a>;
<a name="l00525"></a>00525   }
<a name="l00526"></a>00526   <a class="code" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be" title="Sticky error status of the FLASHC.">flashc_error_status</a> = error_status;
<a name="l00527"></a>00527 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="a7670e69d41fe6a985ad898be25044caf"></a><!-- doxytag: member="flashc.c::flashc_write_gp_fuse_byte" ref="a7670e69d41fe6a985ad898be25044caf" args="(unsigned int gp_fuse_byte, U8 value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_write_gp_fuse_byte </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>gp_fuse_byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U8&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a general-purpose fuse byte. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>gp_fuse_byte</em>&nbsp;</td><td>The general-purpose fuse byte: <code>0</code> to <code>7</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The value of the specified general-purpose fuse byte.</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the Security bit is active.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
A write operation can only clear bits.</dd>
<dd>
The actual number of general-purpose fuse bits implemented by hardware is given by <code>AVR32_FLASHC_GPF_NUM</code>. The other bits among the 64 are fixed at 1 by hardware. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00530">530</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00481">flashc_erase_gp_fuse_byte()</a>, <a class="el" href="a00022_source.html#l00573">flashc_set_gp_fuse_byte()</a>, and <a class="el" href="a00022_source.html#l00536">flashc_write_all_gp_fuses()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00531"></a>00531 {
<a name="l00532"></a>00532   <a class="code" href="a00022.html#a8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_PGPFB, (gp_fuse_byte &amp; 0x07) | value &lt;&lt; 3);
<a name="l00533"></a>00533 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="aa10438433246139bee71da6db2bb5bd5"></a><!-- doxytag: member="flashc.c::flashc_write_page" ref="aa10438433246139bee71da6db2bb5bd5" args="(int page_number)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_write_page </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>page_number</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes a page from the page buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>page_number</em>&nbsp;</td><td>The page number: </p>
<ul>
<li><code>0</code> to <code>(<a class="el" href="a00022.html#aafad0dcf645cc65acb5bc879558dac23" title="Gets the total number of pages in the flash array.">flashc_get_page_count()</a> - 1)</code>: a page number within the flash array; </li>
<li><code>&lt; 0</code>: the current page number.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="warning"><dt><b>Warning:</b></dt><dd>A Lock Error is issued if the command is applied to a page belonging to a locked region or to the bootloader protected area.</dd>
<dd>
The page buffer is not automatically reset after a page write.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
A write operation can only clear bits. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00669">669</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00886">flashc_memcpy()</a>, and <a class="el" href="a00022_source.html#l00713">flashc_memset64()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00670"></a>00670 {
<a name="l00671"></a>00671   <a class="code" href="a00022.html#a8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_WP, page_number);
<a name="l00672"></a>00672 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<a class="anchor" id="ad04374b721dca9c534d7cd041ae24712"></a><!-- doxytag: member="flashc.c::flashc_write_user_page" ref="ad04374b721dca9c534d7cd041ae24712" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void flashc_write_user_page </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes the User page from the page buffer. </p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>The page buffer is not automatically reset after a page write.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>The FLASHC error status returned by <a class="el" href="a00023.html#aa5e4eb7ae688be5d59fca4bb6a326447">flashc_is_lock_error</a> and <a class="el" href="a00023.html#a2556a29213a1be8df40df2f8868077bd">flashc_is_programming_error</a> is updated.</dd>
<dd>
A write operation can only clear bits. </dd></dl>

<p>Definition at line <a class="el" href="a00022_source.html#l00689">689</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>References <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00886">flashc_memcpy()</a>, and <a class="el" href="a00022_source.html#l00713">flashc_memset64()</a>.</p>

<p><div class="fragment"><pre class="fragment"><a name="l00690"></a>00690 {
<a name="l00691"></a>00691   <a class="code" href="a00022.html#a8045c427c32cf3617e861067d76c9c11" title="Issues a FLASHC command.">flashc_issue_command</a>(AVR32_FLASHC_FCMD_CMD_WUP, -1);
<a name="l00692"></a>00692 }
</pre></div></p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
</div>
</p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="af22dcfb635e7fa6bf926dc810e40d6be"></a><!-- doxytag: member="flashc.c::flashc_error_status" ref="af22dcfb635e7fa6bf926dc810e40d6be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int <a class="el" href="a00022.html#af22dcfb635e7fa6bf926dc810e40d6be">flashc_error_status</a> = 0<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sticky error status of the FLASHC. </p>
<p>This variable is updated by functions that issue FLASHC commands. It contains the cumulated FLASHC error status of all the FLASHC commands issued by a function. </p>

<p>Definition at line <a class="el" href="a00022_source.html#l00263">263</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00654">flashc_erase_all_pages()</a>, <a class="el" href="a00022_source.html#l00465">flashc_erase_gp_fuse_bitfield()</a>, <a class="el" href="a00022_source.html#l00481">flashc_erase_gp_fuse_byte()</a>, <a class="el" href="a00022_source.html#l00640">flashc_erase_page()</a>, <a class="el" href="a00022_source.html#l00266">flashc_is_lock_error()</a>, <a class="el" href="a00022_source.html#l00272">flashc_is_programming_error()</a>, <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>, <a class="el" href="a00022_source.html#l00413">flashc_lock_all_regions()</a>, <a class="el" href="a00022_source.html#l00886">flashc_memcpy()</a>, <a class="el" href="a00022_source.html#l00713">flashc_memset64()</a>, <a class="el" href="a00022_source.html#l00593">flashc_set_all_gp_fuses()</a>, <a class="el" href="a00022_source.html#l00558">flashc_set_gp_fuse_bitfield()</a>, <a class="el" href="a00022_source.html#l00573">flashc_set_gp_fuse_byte()</a>, <a class="el" href="a00022_source.html#l00536">flashc_write_all_gp_fuses()</a>, and <a class="el" href="a00022_source.html#l00515">flashc_write_gp_fuse_bitfield()</a>.</p>

</div>
</div>
<a class="anchor" id="a180c9966f5242650e00e4a231956acec"></a><!-- doxytag: member="flashc.c::flashc_wait_until_ready" ref="a180c9966f5242650e00e4a231956acec" args=")(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(*volatile <a class="el" href="a00023.html#a180c9966f5242650e00e4a231956acec">flashc_wait_until_ready</a>)(void) = flashc_default_wait_until_ready</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pointer to the function used by the driver when it needs to wait until the FLASHC is ready to run a new command. </p>
<p>The default function is <a class="el" href="a00023.html#aca88002d64a494ca5b796b592834369d">flashc_default_wait_until_ready</a>. The user may change this pointer to use another implementation. </p>

<p>Definition at line <a class="el" href="a00022_source.html#l00239">239</a> of file <a class="el" href="a00022_source.html">flashc.c</a>.</p>

<p>Referenced by <a class="el" href="a00022_source.html#l00298">flashc_issue_command()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Nov 15 14:11:32 2010 for PWM4 Example for uc3c_ek by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
