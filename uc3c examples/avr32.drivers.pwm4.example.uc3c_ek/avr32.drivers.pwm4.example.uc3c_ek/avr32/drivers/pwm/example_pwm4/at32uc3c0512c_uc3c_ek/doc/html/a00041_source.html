<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PWM4 Example for uc3c_ek: scif_uc3c.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<h1>scif_uc3c.c</h1><a href="a00041.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*This file has been prepared for Doxygen automatic documentation generation.*/</span>
<a name="l00016"></a>00016 <span class="comment">/* Copyright (c) 2009 Atmel Corporation. All rights reserved.</span>
<a name="l00017"></a>00017 <span class="comment"> *</span>
<a name="l00018"></a>00018 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
<a name="l00019"></a>00019 <span class="comment"> * modification, are permitted provided that the following conditions are met:</span>
<a name="l00020"></a>00020 <span class="comment"> *</span>
<a name="l00021"></a>00021 <span class="comment"> * 1. Redistributions of source code must retain the above copyright notice, this</span>
<a name="l00022"></a>00022 <span class="comment"> * list of conditions and the following disclaimer.</span>
<a name="l00023"></a>00023 <span class="comment"> *</span>
<a name="l00024"></a>00024 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright notice,</span>
<a name="l00025"></a>00025 <span class="comment"> * this list of conditions and the following disclaimer in the documentation</span>
<a name="l00026"></a>00026 <span class="comment"> * and/or other materials provided with the distribution.</span>
<a name="l00027"></a>00027 <span class="comment"> *</span>
<a name="l00028"></a>00028 <span class="comment"> * 3. The name of Atmel may not be used to endorse or promote products derived</span>
<a name="l00029"></a>00029 <span class="comment"> * from this software without specific prior written permission.</span>
<a name="l00030"></a>00030 <span class="comment"> *</span>
<a name="l00031"></a>00031 <span class="comment"> * 4. This software may only be redistributed and used in connection with an Atmel</span>
<a name="l00032"></a>00032 <span class="comment"> * AVR product.</span>
<a name="l00033"></a>00033 <span class="comment"> *</span>
<a name="l00034"></a>00034 <span class="comment"> * THIS SOFTWARE IS PROVIDED BY ATMEL &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED</span>
<a name="l00035"></a>00035 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF</span>
<a name="l00036"></a>00036 <span class="comment"> * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE</span>
<a name="l00037"></a>00037 <span class="comment"> * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR</span>
<a name="l00038"></a>00038 <span class="comment"> * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES</span>
<a name="l00039"></a>00039 <span class="comment"> * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;</span>
<a name="l00040"></a>00040 <span class="comment"> * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
<a name="l00041"></a>00041 <span class="comment"> * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00042"></a>00042 <span class="comment"> * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</span>
<a name="l00043"></a>00043 <span class="comment"> * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE</span>
<a name="l00044"></a>00044 <span class="comment"> *</span>
<a name="l00045"></a>00045 <span class="comment"> */</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;<a class="code" href="a00021.html" title="Compiler file for AVR32.">compiler.h</a>&quot;</span>
<a name="l00048"></a>00048 <span class="preprocessor">#include &quot;<a class="code" href="a00042.html" title="System Control InterFace(SCIF) driver interface.">scif_uc3c.h</a>&quot;</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 
<a name="l00055"></a><a class="code" href="a00018.html">00055</a> <span class="keyword">typedef</span> <span class="keyword">union</span>
<a name="l00056"></a>00056 {
<a name="l00057"></a><a class="code" href="a00018.html#a7dad485905ddfae2fc273f193824eadb">00057</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>                 oscctrl[2];
<a name="l00058"></a><a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">00058</a>   avr32_scif_oscctrl_t          OSCCTRL[2];
<a name="l00059"></a>00059 } <a class="code" href="a00018.html">u_avr32_scif_oscctrl_t</a>;
<a name="l00060"></a>00060 
<a name="l00061"></a><a class="code" href="a00019.html">00061</a> <span class="keyword">typedef</span> <span class="keyword">union</span>
<a name="l00062"></a>00062 {
<a name="l00063"></a><a class="code" href="a00019.html#ace0e01d815be355b6a5614bf12cb6806">00063</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>                 pll[2];
<a name="l00064"></a><a class="code" href="a00019.html#ae4b06442c68ab961ebd544fb12b7018e">00064</a>   avr32_scif_pll_t              PLL[2];
<a name="l00065"></a>00065 } <a class="code" href="a00019.html">u_avr32_scif_pll_t</a>;
<a name="l00066"></a>00066 
<a name="l00067"></a><a class="code" href="a00017.html">00067</a> <span class="keyword">typedef</span> <span class="keyword">union</span>
<a name="l00068"></a>00068 {
<a name="l00069"></a><a class="code" href="a00017.html#a29f7f13d957ead97f8a3e4707c676e98">00069</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>                 oscctrl32;
<a name="l00070"></a><a class="code" href="a00017.html#a9272a4e5c4da7e51c36d36dc497b9a7b">00070</a>   avr32_scif_oscctrl32_t         OSCCTRL32;
<a name="l00071"></a>00071 } <a class="code" href="a00017.html">u_avr32_scif_oscctrl32_t</a>;
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="comment">//----- PRIVATE FUNCTIONS</span>
<a name="l00079"></a>00079 
<a name="l00088"></a><a class="code" href="a00041.html#a5f0069245d4d5cbfea5cb6b3300a6c0b">00088</a> <span class="keyword">static</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="a00041.html#a5f0069245d4d5cbfea5cb6b3300a6c0b" title="Wait for a status high in the Power and Clocks status register.">scif_pclksr_statushigh_wait</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> statusMask)
<a name="l00089"></a>00089 {
<a name="l00090"></a>00090   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  timeout = <a class="code" href="a00042.html#a8758fcbbde760fe3498dd00acf238407" title="The timeguard used for polling in ticks.">SCIF_POLL_TIMEOUT</a>;
<a name="l00091"></a>00091   
<a name="l00092"></a>00092   <span class="keywordflow">while</span>(!(AVR32_SCIF.pclksr &amp; statusMask))
<a name="l00093"></a>00093   {
<a name="l00094"></a>00094     <span class="keywordflow">if</span>(--timeout == 0)
<a name="l00095"></a>00095       <span class="keywordflow">return</span> -1;
<a name="l00096"></a>00096   }
<a name="l00097"></a>00097   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00098"></a>00098 }
<a name="l00099"></a>00099 
<a name="l00100"></a><a class="code" href="a00042.html#a5fcd05f3e28de6dae627d4d8bc1d73f5">00100</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00041.html#a5fcd05f3e28de6dae627d4d8bc1d73f5" title="Read the content of the SCIF GPLP registers.">scif_read_gplp</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> gplp)
<a name="l00101"></a>00101 {
<a name="l00102"></a>00102   <span class="keywordflow">return</span> AVR32_SCIF.gplp[gplp];
<a name="l00103"></a>00103 }
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 
<a name="l00106"></a><a class="code" href="a00042.html#ada5eb12275d8fb7f8040bfcd043e5cc3">00106</a> <span class="keywordtype">void</span> <a class="code" href="a00041.html#ada5eb12275d8fb7f8040bfcd043e5cc3" title="Write into the SCIF GPLP registers.">scif_write_gplp</a>(<span class="keywordtype">int</span> gplp, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value)
<a name="l00107"></a>00107 {
<a name="l00108"></a>00108   <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_GPLP + 4*gplp); 
<a name="l00109"></a>00109   AVR32_SCIF.gplp[gplp] = value;
<a name="l00110"></a>00110 }
<a name="l00111"></a>00111 
<a name="l00115"></a>00115 <span class="comment">// Implemented as inline in scif_uc3x.h</span>
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 
<a name="l00121"></a>00121 <span class="comment">// Implemented as inline in scif_uc3x.h</span>
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 
<a name="l00128"></a><a class="code" href="a00042.html#a00ceb53ef51dd175ee30bc461155763b">00128</a> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="a00041.html#a00ceb53ef51dd175ee30bc461155763b" title="Interrupt Functions.">scif_start_osc</a>(<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644" title="The different oscillators.">scif_osc_t</a> osc, <span class="keyword">const</span> <a class="code" href="a00008.html" title="OSC0/OSC1 startup options.">scif_osc_opt_t</a> *opt, <span class="keywordtype">bool</span> wait_for_ready)
<a name="l00129"></a>00129 {
<a name="l00130"></a>00130   <a class="code" href="a00018.html">u_avr32_scif_oscctrl_t</a>   u_avr32_scif_oscctrl;
<a name="l00131"></a>00131   
<a name="l00132"></a>00132 <span class="preprocessor">#ifdef AVR32SFW_INPUT_CHECK</span>
<a name="l00133"></a>00133 <span class="preprocessor"></span>  <span class="comment">// Check that the input frequency is in the supported frequency range.</span>
<a name="l00134"></a>00134   <span class="keywordflow">if</span>( (opt-&gt;<a class="code" href="a00008.html#a6a60d571530d7b7eabe0cf5eefe6fe7a" title="The input frequency (from the external clock or the crystal).">freq_hz</a> &lt; <a class="code" href="a00042.html#a6ec08d0cd02a6104e0f98f22b94d0fb4" title="Device-specific data.">SCIF_EXT_CRYSTAL_MIN_FREQ_HZ</a>)
<a name="l00135"></a>00135       || (opt-&gt;<a class="code" href="a00008.html#a6a60d571530d7b7eabe0cf5eefe6fe7a" title="The input frequency (from the external clock or the crystal).">freq_hz</a> &gt; <a class="code" href="a00042.html#a00368dbc88219075cb01d352b2725c82">SCIF_EXT_CRYSTAL_MAX_FREQ_HZ</a>))
<a name="l00136"></a>00136   {
<a name="l00137"></a>00137     <span class="keywordflow">return</span> -1;
<a name="l00138"></a>00138   }
<a name="l00139"></a>00139   <span class="comment">// Check : for OSC0/OSC1, only 2 modes are supported</span>
<a name="l00140"></a>00140   <span class="keywordflow">if</span>( (opt-&gt;<a class="code" href="a00008.html#a1cd9d6f0cb38d71a344fbdab1fe90337" title="Set the oscillator mode.">mode</a> != <a class="code" href="a00042.html#a9a708e94c5df197717f5859f6b8b257caab4ef315627644c27b21ace5afcc3aac">SCIF_OSC_MODE_EXT_CLK</a>)
<a name="l00141"></a>00141       &amp;&amp; (opt-&gt;<a class="code" href="a00008.html#a1cd9d6f0cb38d71a344fbdab1fe90337" title="Set the oscillator mode.">mode</a> != <a class="code" href="a00042.html#a9a708e94c5df197717f5859f6b8b257ca3b93142664c5679290dcacf047360aae">SCIF_OSC_MODE_2PIN_CRYSTAL</a>))
<a name="l00142"></a>00142   {
<a name="l00143"></a>00143     <span class="keywordflow">return</span> -1;
<a name="l00144"></a>00144   }
<a name="l00145"></a>00145   
<a name="l00146"></a>00146   <span class="keywordflow">if</span> (osc == <a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644a6cbdcff7051100ba50af09439fbb0122">SCIF_OSC0</a>)
<a name="l00147"></a>00147   {
<a name="l00148"></a>00148     <span class="comment">// Check that the startup value is in the supported range.</span>
<a name="l00149"></a>00149     <span class="keywordflow">if</span>(opt-&gt;<a class="code" href="a00008.html#aa056d244d7d751361c02bd7d29c06b69" title="Specify the oscillator startup time.">startup</a> &gt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)AVR32_SCIF_OSCCTRL0_STARTUP_16384_RCOSC)
<a name="l00150"></a>00150     {
<a name="l00151"></a>00151       <span class="keywordflow">return</span> -1;
<a name="l00152"></a>00152     }
<a name="l00153"></a>00153     <span class="comment">// Check that the gain value is in the supported range.</span>
<a name="l00154"></a>00154     <span class="keywordflow">if</span>(opt-&gt;<a class="code" href="a00008.html#a6642c00d5955b3fb3a2cbd3320977f23" title="Gain for the oscillator.">gain</a> &gt; AVR32_SCIF_OSCCTRL0_GAIN_G3)
<a name="l00155"></a>00155     {
<a name="l00156"></a>00156       <span class="keywordflow">return</span> -1;
<a name="l00157"></a>00157     }
<a name="l00158"></a>00158   }
<a name="l00159"></a>00159   <span class="keywordflow">else</span>
<a name="l00160"></a>00160   {
<a name="l00161"></a>00161     <span class="comment">// Check that the startup value is in the supported range.</span>
<a name="l00162"></a>00162     <span class="keywordflow">if</span>(opt-&gt;<a class="code" href="a00008.html#aa056d244d7d751361c02bd7d29c06b69" title="Specify the oscillator startup time.">startup</a> &gt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)AVR32_SCIF_OSCCTRL1_STARTUP_16384_RCOSC)
<a name="l00163"></a>00163     {
<a name="l00164"></a>00164       <span class="keywordflow">return</span> -1;
<a name="l00165"></a>00165     }
<a name="l00166"></a>00166     <span class="comment">// Check that the gain value is in the supported range.</span>
<a name="l00167"></a>00167     <span class="keywordflow">if</span>(opt-&gt;<a class="code" href="a00008.html#a6642c00d5955b3fb3a2cbd3320977f23" title="Gain for the oscillator.">gain</a> &gt; AVR32_SCIF_OSCCTRL1_GAIN_G3)
<a name="l00168"></a>00168     {
<a name="l00169"></a>00169       <span class="keywordflow">return</span> -1;
<a name="l00170"></a>00170     }  
<a name="l00171"></a>00171   }
<a name="l00172"></a>00172 <span class="preprocessor">#endif  // AVR32SFW_INPUT_CHECK</span>
<a name="l00173"></a>00173 <span class="preprocessor"></span>  <span class="comment">// Read Register</span>
<a name="l00174"></a>00174   u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[osc] = AVR32_SCIF.OSCCTRL[osc] ;
<a name="l00175"></a>00175   <span class="comment">// Modify: Configure &amp; start OSC0.</span>
<a name="l00176"></a>00176   u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[osc].mode = opt-&gt;<a class="code" href="a00008.html#a1cd9d6f0cb38d71a344fbdab1fe90337" title="Set the oscillator mode.">mode</a>;
<a name="l00177"></a>00177   u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[osc].gain = opt-&gt;<a class="code" href="a00008.html#a6642c00d5955b3fb3a2cbd3320977f23" title="Gain for the oscillator.">gain</a>;
<a name="l00178"></a>00178   u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[osc].startup = opt-&gt;<a class="code" href="a00008.html#aa056d244d7d751361c02bd7d29c06b69" title="Specify the oscillator startup time.">startup</a>;
<a name="l00179"></a>00179   u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[osc].oscen = <a class="code" href="a00021.html#a514ad415fb6125ba296793df7d1a468a">ENABLE</a>;
<a name="l00180"></a>00180   <a class="code" href="a00050.html#ga6614d1866189f3f0c9a66e5c18e6a261" title="Start section with code protected against interrupts.">AVR32_ENTER_CRITICAL_REGION</a>( );
<a name="l00181"></a>00181   <span class="comment">// Unlock the write-protected OSCCTRL0 register</span>
<a name="l00182"></a>00182   <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_OSCCTRL + 4*osc);    
<a name="l00183"></a>00183   <span class="comment">// Write Back</span>
<a name="l00184"></a>00184   AVR32_SCIF.OSCCTRL[osc] = u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[osc];
<a name="l00185"></a>00185   <a class="code" href="a00050.html#ga85b7f1705a7949f2e8dfacb071e00c6a" title="End section with code protected against interrupts.">AVR32_LEAVE_CRITICAL_REGION</a>( );
<a name="l00186"></a>00186 
<a name="l00187"></a>00187   <span class="keywordflow">if</span>(<span class="keyword">true</span> == wait_for_ready)
<a name="l00188"></a>00188   {
<a name="l00189"></a>00189     <span class="comment">// Wait until OSC0 is stable and ready to be used.</span>
<a name="l00190"></a>00190     <span class="keywordflow">if</span>(<a class="code" href="a00041.html#a5f0069245d4d5cbfea5cb6b3300a6c0b" title="Wait for a status high in the Power and Clocks status register.">scif_pclksr_statushigh_wait</a>(AVR32_SCIF_PCLKSR_OSC0RDY_MASK))
<a name="l00191"></a>00191       <span class="keywordflow">return</span> -1;
<a name="l00192"></a>00192   }
<a name="l00193"></a>00193   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00194"></a>00194 }
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 
<a name="l00197"></a><a class="code" href="a00042.html#a4d8aa2fd50f3bee4bd1b0f7cd9559f72">00197</a> <span class="keywordtype">bool</span> <a class="code" href="a00041.html#a4d8aa2fd50f3bee4bd1b0f7cd9559f72" title="Is an oscillator stable and ready to be used as clock source?">scif_is_osc_ready</a>(<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644" title="The different oscillators.">scif_osc_t</a> osc)
<a name="l00198"></a>00198 {
<a name="l00199"></a>00199   <span class="keywordflow">if</span> (osc == <a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644a6cbdcff7051100ba50af09439fbb0122">SCIF_OSC0</a>)
<a name="l00200"></a>00200   {
<a name="l00201"></a>00201     <span class="keywordflow">return</span>((AVR32_SCIF.pclksr &amp; AVR32_SCIF_PCLKSR_OSC0RDY_MASK)&gt;&gt;AVR32_SCIF_PCLKSR_OSC0RDY_OFFSET);
<a name="l00202"></a>00202   }
<a name="l00203"></a>00203   <span class="keywordflow">else</span>
<a name="l00204"></a>00204   {
<a name="l00205"></a>00205     <span class="keywordflow">return</span>((AVR32_SCIF.pclksr &amp; AVR32_SCIF_PCLKSR_OSC1RDY_MASK)&gt;&gt;AVR32_SCIF_PCLKSR_OSC1RDY_OFFSET);  
<a name="l00206"></a>00206   }
<a name="l00207"></a>00207 }
<a name="l00208"></a>00208 
<a name="l00209"></a>00209 
<a name="l00210"></a><a class="code" href="a00042.html#a5dca9b966cbe139223b6044b160509e5">00210</a> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="a00041.html#a5dca9b966cbe139223b6044b160509e5" title="Stop an oscillator.">scif_stop_osc</a>(<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644" title="The different oscillators.">scif_osc_t</a> osc)
<a name="l00211"></a>00211 {
<a name="l00212"></a>00212 
<a name="l00213"></a>00213   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> temp;
<a name="l00214"></a>00214 
<a name="l00215"></a>00215   temp = AVR32_SCIF.oscctrl[osc];
<a name="l00216"></a>00216   temp &amp;= ~(AVR32_SCIF_OSCCTRL_OSCEN_DISABLE &lt;&lt; AVR32_SCIF_OSCCTRL_OSCEN_OFFSET);
<a name="l00217"></a>00217   <a class="code" href="a00050.html#ga6614d1866189f3f0c9a66e5c18e6a261" title="Start section with code protected against interrupts.">AVR32_ENTER_CRITICAL_REGION</a>( );
<a name="l00218"></a>00218   <span class="comment">// Unlock the write-protected OSCCTRL0 register</span>
<a name="l00219"></a>00219   <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_OSCCTRL + 4*osc);
<a name="l00220"></a>00220   <span class="comment">// Stop OSC0.</span>
<a name="l00221"></a>00221   AVR32_SCIF.oscctrl[osc] = temp;
<a name="l00222"></a>00222   <a class="code" href="a00050.html#ga85b7f1705a7949f2e8dfacb071e00c6a" title="End section with code protected against interrupts.">AVR32_LEAVE_CRITICAL_REGION</a>( );
<a name="l00223"></a>00223       
<a name="l00224"></a>00224   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00225"></a>00225 }
<a name="l00226"></a>00226 
<a name="l00227"></a>00227 
<a name="l00228"></a><a class="code" href="a00042.html#a07a99c5e193620b3d4a6825bcd054e37">00228</a> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="a00041.html#a07a99c5e193620b3d4a6825bcd054e37" title="Configure an oscillator in crystal mode.">scif_configure_osc_crystalmode</a>(<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644" title="The different oscillators.">scif_osc_t</a> osc, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fcrystal)
<a name="l00229"></a>00229 {
<a name="l00230"></a>00230   <a class="code" href="a00018.html">u_avr32_scif_oscctrl_t</a>   u_avr32_scif_oscctrl;
<a name="l00231"></a>00231   
<a name="l00232"></a>00232   <span class="keywordflow">if</span> (osc == <a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644a6cbdcff7051100ba50af09439fbb0122">SCIF_OSC0</a>)
<a name="l00233"></a>00233   {    
<a name="l00234"></a>00234     <span class="comment">// Read Register</span>
<a name="l00235"></a>00235     u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644a6cbdcff7051100ba50af09439fbb0122">SCIF_OSC0</a>] = AVR32_SCIF.OSCCTRL[<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644a6cbdcff7051100ba50af09439fbb0122">SCIF_OSC0</a>] ;    
<a name="l00236"></a>00236     <span class="comment">// Modify : Configure the oscillator mode to crystal and set the gain according to the</span>
<a name="l00237"></a>00237     <span class="comment">// cyrstal frequency.</span>
<a name="l00238"></a>00238     u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644a6cbdcff7051100ba50af09439fbb0122">SCIF_OSC0</a>].mode = <a class="code" href="a00042.html#a9a708e94c5df197717f5859f6b8b257ca3b93142664c5679290dcacf047360aae">SCIF_OSC_MODE_2PIN_CRYSTAL</a>;
<a name="l00239"></a>00239     u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644a6cbdcff7051100ba50af09439fbb0122">SCIF_OSC0</a>].gain = (fcrystal &lt;  900000) ? AVR32_SCIF_OSCCTRL0_GAIN_G0 :
<a name="l00240"></a>00240                                                    (fcrystal &lt; 3000000) ? AVR32_SCIF_OSCCTRL0_GAIN_G1 :
<a name="l00241"></a>00241                                                    (fcrystal &lt; 8000000) ? AVR32_SCIF_OSCCTRL0_GAIN_G2 :
<a name="l00242"></a>00242                                                                           AVR32_SCIF_OSCCTRL0_GAIN_G3;
<a name="l00243"></a>00243     <a class="code" href="a00050.html#ga6614d1866189f3f0c9a66e5c18e6a261" title="Start section with code protected against interrupts.">AVR32_ENTER_CRITICAL_REGION</a>( );
<a name="l00244"></a>00244     <span class="comment">// Unlock the write-protected OSCCTRL0 register</span>
<a name="l00245"></a>00245     <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_OSCCTRL);
<a name="l00246"></a>00246     <span class="comment">// Write Back</span>
<a name="l00247"></a>00247     AVR32_SCIF.OSCCTRL[<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644a6cbdcff7051100ba50af09439fbb0122">SCIF_OSC0</a>] = u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644a6cbdcff7051100ba50af09439fbb0122">SCIF_OSC0</a>];
<a name="l00248"></a>00248     <a class="code" href="a00050.html#ga85b7f1705a7949f2e8dfacb071e00c6a" title="End section with code protected against interrupts.">AVR32_LEAVE_CRITICAL_REGION</a>( );
<a name="l00249"></a>00249   }
<a name="l00250"></a>00250   <span class="keywordflow">else</span>
<a name="l00251"></a>00251   { 
<a name="l00252"></a>00252     <span class="comment">// Read Register</span>
<a name="l00253"></a>00253     u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644a79fa8a5ea1f7726cd4a35c556cf83380">SCIF_OSC1</a>] = AVR32_SCIF.OSCCTRL[<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644a79fa8a5ea1f7726cd4a35c556cf83380">SCIF_OSC1</a>] ;    
<a name="l00254"></a>00254     <span class="comment">// Modify : Configure the oscillator mode to crystal and set the gain according to the</span>
<a name="l00255"></a>00255     <span class="comment">// cyrstal frequency.</span>
<a name="l00256"></a>00256     u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644a79fa8a5ea1f7726cd4a35c556cf83380">SCIF_OSC1</a>].mode = <a class="code" href="a00042.html#a9a708e94c5df197717f5859f6b8b257ca3b93142664c5679290dcacf047360aae">SCIF_OSC_MODE_2PIN_CRYSTAL</a>;
<a name="l00257"></a>00257     u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644a79fa8a5ea1f7726cd4a35c556cf83380">SCIF_OSC1</a>].gain = (fcrystal &lt;  900000) ? AVR32_SCIF_OSCCTRL1_GAIN_G0 :
<a name="l00258"></a>00258                                                    (fcrystal &lt; 3000000) ? AVR32_SCIF_OSCCTRL1_GAIN_G1 :
<a name="l00259"></a>00259                                                    (fcrystal &lt; 8000000) ? AVR32_SCIF_OSCCTRL1_GAIN_G2 :
<a name="l00260"></a>00260                                                                           AVR32_SCIF_OSCCTRL1_GAIN_G3;
<a name="l00261"></a>00261     <a class="code" href="a00050.html#ga6614d1866189f3f0c9a66e5c18e6a261" title="Start section with code protected against interrupts.">AVR32_ENTER_CRITICAL_REGION</a>( );
<a name="l00262"></a>00262     <span class="comment">// Unlock the write-protected OSCCTRL1 register</span>
<a name="l00263"></a>00263     <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_OSCCTRL + 4);
<a name="l00264"></a>00264     <span class="comment">// Write Back</span>
<a name="l00265"></a>00265     AVR32_SCIF.OSCCTRL[<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644a79fa8a5ea1f7726cd4a35c556cf83380">SCIF_OSC1</a>] = u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644a79fa8a5ea1f7726cd4a35c556cf83380">SCIF_OSC1</a>];
<a name="l00266"></a>00266     <a class="code" href="a00050.html#ga85b7f1705a7949f2e8dfacb071e00c6a" title="End section with code protected against interrupts.">AVR32_LEAVE_CRITICAL_REGION</a>( );
<a name="l00267"></a>00267   }
<a name="l00268"></a>00268 
<a name="l00269"></a>00269   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00270"></a>00270 }
<a name="l00271"></a>00271 
<a name="l00272"></a><a class="code" href="a00042.html#a4406d9a27fdfbedf364ff4b571fd9fa2">00272</a> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="a00041.html#a4406d9a27fdfbedf364ff4b571fd9fa2" title="Configure an external clock as input clock.">scif_configure_osc_extmode</a>(<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644" title="The different oscillators.">scif_osc_t</a> osc)
<a name="l00273"></a>00273 {
<a name="l00274"></a>00274   <a class="code" href="a00018.html">u_avr32_scif_oscctrl_t</a>   u_avr32_scif_oscctrl;
<a name="l00275"></a>00275   
<a name="l00276"></a>00276       <span class="comment">// Read Register</span>
<a name="l00277"></a>00277     u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[osc] = AVR32_SCIF.OSCCTRL[osc] ;
<a name="l00278"></a>00278     <span class="comment">// Modify : Configure the oscillator mode to crystal and set the gain according to the</span>
<a name="l00279"></a>00279     <span class="comment">// cyrstal frequency.</span>
<a name="l00280"></a>00280     u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[osc].mode = <a class="code" href="a00042.html#a9a708e94c5df197717f5859f6b8b257caab4ef315627644c27b21ace5afcc3aac">SCIF_OSC_MODE_EXT_CLK</a>;
<a name="l00281"></a>00281     <a class="code" href="a00050.html#ga6614d1866189f3f0c9a66e5c18e6a261" title="Start section with code protected against interrupts.">AVR32_ENTER_CRITICAL_REGION</a>( );
<a name="l00282"></a>00282     <span class="comment">// Unlock the write-protected OSCCTRL0 register</span>
<a name="l00283"></a>00283     <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_OSCCTRL + 4*osc);
<a name="l00284"></a>00284     <span class="comment">// Write Back</span>
<a name="l00285"></a>00285     AVR32_SCIF.OSCCTRL[osc] = u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[osc];
<a name="l00286"></a>00286     <a class="code" href="a00050.html#ga85b7f1705a7949f2e8dfacb071e00c6a" title="End section with code protected against interrupts.">AVR32_LEAVE_CRITICAL_REGION</a>( );
<a name="l00287"></a>00287 
<a name="l00288"></a>00288   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00289"></a>00289 }
<a name="l00290"></a>00290 
<a name="l00291"></a><a class="code" href="a00042.html#ae6a41bbff30ad3544abd620bb8b50612">00291</a> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="a00041.html#ae6a41bbff30ad3544abd620bb8b50612" title="Enable an oscillator with a given startup time.">scif_enable_osc</a>(<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644" title="The different oscillators.">scif_osc_t</a> osc, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> startup, <span class="keywordtype">bool</span> wait_for_ready)
<a name="l00292"></a>00292 {
<a name="l00293"></a>00293 
<a name="l00294"></a>00294   <a class="code" href="a00018.html">u_avr32_scif_oscctrl_t</a>   u_avr32_scif_oscctrl;
<a name="l00295"></a>00295 
<a name="l00296"></a>00296   <span class="comment">// Read Register</span>
<a name="l00297"></a>00297   u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[osc] = AVR32_SCIF.OSCCTRL[osc] ;      
<a name="l00298"></a>00298   <span class="comment">// Modify: Configure the oscillator startup and enable the osc.</span>
<a name="l00299"></a>00299   u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[osc].startup = startup;
<a name="l00300"></a>00300   u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[osc].oscen = <a class="code" href="a00021.html#a514ad415fb6125ba296793df7d1a468a">ENABLE</a>;
<a name="l00301"></a>00301   <a class="code" href="a00050.html#ga6614d1866189f3f0c9a66e5c18e6a261" title="Start section with code protected against interrupts.">AVR32_ENTER_CRITICAL_REGION</a>( );
<a name="l00302"></a>00302   <span class="comment">// Unlock the write-protected OSCCTRL0 register</span>
<a name="l00303"></a>00303   <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_OSCCTRL + 4*osc);
<a name="l00304"></a>00304   <span class="comment">// Write Back</span>
<a name="l00305"></a>00305   AVR32_SCIF.OSCCTRL[osc] = u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[osc];
<a name="l00306"></a>00306   <a class="code" href="a00050.html#ga85b7f1705a7949f2e8dfacb071e00c6a" title="End section with code protected against interrupts.">AVR32_LEAVE_CRITICAL_REGION</a>( );
<a name="l00307"></a>00307 
<a name="l00308"></a>00308   <span class="keywordflow">if</span>(<span class="keyword">true</span> == wait_for_ready)
<a name="l00309"></a>00309   {
<a name="l00310"></a>00310     <span class="comment">// Wait until OSC0 is stable and ready to be used.</span>
<a name="l00311"></a>00311     <span class="keywordflow">if</span>(<a class="code" href="a00041.html#a5f0069245d4d5cbfea5cb6b3300a6c0b" title="Wait for a status high in the Power and Clocks status register.">scif_pclksr_statushigh_wait</a>(AVR32_SCIF_PCLKSR_OSC0RDY_MASK))
<a name="l00312"></a>00312       <span class="keywordflow">return</span> -1;
<a name="l00313"></a>00313   }
<a name="l00314"></a>00314       
<a name="l00315"></a>00315   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00316"></a>00316 }
<a name="l00317"></a>00317 
<a name="l00318"></a><a class="code" href="a00042.html#a78cb0ccfb114e27d63cc8fd317648def">00318</a> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="a00041.html#a78cb0ccfb114e27d63cc8fd317648def" title="Enable external clock.">scif_enable_extosc</a>(<a class="code" href="a00042.html#af09989f8fb441a8d3806b7fe60fdc644" title="The different oscillators.">scif_osc_t</a> osc)
<a name="l00319"></a>00319 {
<a name="l00320"></a>00320 
<a name="l00321"></a>00321   <a class="code" href="a00018.html">u_avr32_scif_oscctrl_t</a>   u_avr32_scif_oscctrl;
<a name="l00322"></a>00322 
<a name="l00323"></a>00323   <span class="comment">// Read Register</span>
<a name="l00324"></a>00324   u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[osc] = AVR32_SCIF.OSCCTRL[osc] ;    
<a name="l00325"></a>00325   <span class="comment">// Modify : Enable the osc.</span>
<a name="l00326"></a>00326   u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[osc].oscen = <a class="code" href="a00021.html#a514ad415fb6125ba296793df7d1a468a">ENABLE</a>;
<a name="l00327"></a>00327   <a class="code" href="a00050.html#ga6614d1866189f3f0c9a66e5c18e6a261" title="Start section with code protected against interrupts.">AVR32_ENTER_CRITICAL_REGION</a>( );
<a name="l00328"></a>00328   <span class="comment">// Unlock the write-protected OSCCTRL0 register</span>
<a name="l00329"></a>00329   <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_OSCCTRL + 4*osc);
<a name="l00330"></a>00330   <span class="comment">// Write Back</span>
<a name="l00331"></a>00331   AVR32_SCIF.OSCCTRL[osc] = u_avr32_scif_oscctrl.<a class="code" href="a00018.html#a37be34efbc57410513d31b59270e7f4e">OSCCTRL</a>[osc];
<a name="l00332"></a>00332   <a class="code" href="a00050.html#ga85b7f1705a7949f2e8dfacb071e00c6a" title="End section with code protected against interrupts.">AVR32_LEAVE_CRITICAL_REGION</a>( );
<a name="l00333"></a>00333   
<a name="l00334"></a>00334   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00335"></a>00335 }
<a name="l00336"></a>00336 
<a name="l00340"></a><a class="code" href="a00042.html#a0762c326026298131479b2eb6c66966e">00340</a> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="a00041.html#a0762c326026298131479b2eb6c66966e" title="PLL0/PLL1 Functions.">scif_pll_setup</a>(<a class="code" href="a00042.html#aee67e9247cde3191caf3a6ec8cc49131" title="The different plls.">scif_pll_t</a> pll, <span class="keyword">const</span> <a class="code" href="a00009.html" title="PLL0/PLL1 startup options.">scif_pll_opt_t</a> opt)
<a name="l00341"></a>00341 {
<a name="l00342"></a>00342 
<a name="l00343"></a>00343   <a class="code" href="a00019.html">u_avr32_scif_pll_t</a>   u_avr32_scif_pll;
<a name="l00344"></a>00344 
<a name="l00345"></a>00345   <span class="comment">// Read Register</span>
<a name="l00346"></a>00346   u_avr32_scif_pll.<a class="code" href="a00019.html#ae4b06442c68ab961ebd544fb12b7018e">PLL</a>[pll] = AVR32_SCIF.PLL[pll] ;
<a name="l00347"></a>00347   <span class="comment">// Modify Configuration </span>
<a name="l00348"></a>00348   u_avr32_scif_pll.<a class="code" href="a00019.html#ae4b06442c68ab961ebd544fb12b7018e">PLL</a>[pll].pllosc  = opt.<a class="code" href="a00009.html#aee09a41840d5059cbb116689ea851d0f" title="Specify the scillator input.">osc</a>;
<a name="l00349"></a>00349   u_avr32_scif_pll.<a class="code" href="a00019.html#ae4b06442c68ab961ebd544fb12b7018e">PLL</a>[pll].pllopt  = opt.<a class="code" href="a00009.html#ae397f441f9093a691a6e74fa777dd939" title="Set to 1 for VCO frequency range 80-180MHz, set to 0 for VCO frequency range 160-240Mhz...">pll_freq</a> | (opt.<a class="code" href="a00009.html#af1afe250ff51e752c3edf06da9f25aad" title="Divide the PLL output frequency by 2. (this settings does not change the FVCO value)...">pll_div2</a> &lt;&lt; 1) | (opt.<a class="code" href="a00009.html#a4740e279139f74bfc8e5b0a03877afea" title="1 Disable the Wide-Bandith Mode (Wide-Bandwith mode allow a faster startup time and...">pll_wbwdisable</a> &lt;&lt; 2);
<a name="l00350"></a>00350   u_avr32_scif_pll.<a class="code" href="a00019.html#ae4b06442c68ab961ebd544fb12b7018e">PLL</a>[pll].plldiv   = opt.<a class="code" href="a00009.html#ac5f2397759d35572bfeeab93dda0c776" title="PLL DIV in the PLL formula.">div</a>;
<a name="l00351"></a>00351   u_avr32_scif_pll.<a class="code" href="a00019.html#ae4b06442c68ab961ebd544fb12b7018e">PLL</a>[pll].pllmul  = opt.<a class="code" href="a00009.html#aae5047440f34de93ea589e39e4ce94da" title="PLL MUL in the PLL formula.">mul</a>;
<a name="l00352"></a>00352   u_avr32_scif_pll.<a class="code" href="a00019.html#ae4b06442c68ab961ebd544fb12b7018e">PLL</a>[pll].pllcount= opt.<a class="code" href="a00009.html#a34359a906929e13a238b290925d1dff8" title="PLL lockount.">lockcount</a>;
<a name="l00353"></a>00353   <a class="code" href="a00050.html#ga6614d1866189f3f0c9a66e5c18e6a261" title="Start section with code protected against interrupts.">AVR32_ENTER_CRITICAL_REGION</a>( );
<a name="l00354"></a>00354   <span class="comment">// Unlock the write-protected PLL0 register</span>
<a name="l00355"></a>00355   <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_PLL + 4*pll); 
<a name="l00356"></a>00356   <span class="comment">// Write Back</span>
<a name="l00357"></a>00357   AVR32_SCIF.PLL[pll] = u_avr32_scif_pll.<a class="code" href="a00019.html#ae4b06442c68ab961ebd544fb12b7018e">PLL</a>[pll];
<a name="l00358"></a>00358   <a class="code" href="a00050.html#ga85b7f1705a7949f2e8dfacb071e00c6a" title="End section with code protected against interrupts.">AVR32_LEAVE_CRITICAL_REGION</a>( );
<a name="l00359"></a>00359 
<a name="l00360"></a>00360   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00361"></a>00361 }
<a name="l00362"></a>00362 
<a name="l00363"></a><a class="code" href="a00042.html#afb379ef54174ea12680afe48a82c14b9">00363</a> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="a00041.html#afb379ef54174ea12680afe48a82c14b9" title="This function will enable a PLL.">scif_pll_enable</a>(<a class="code" href="a00042.html#aee67e9247cde3191caf3a6ec8cc49131" title="The different plls.">scif_pll_t</a> pll)
<a name="l00364"></a>00364 {
<a name="l00365"></a>00365 
<a name="l00366"></a>00366   <a class="code" href="a00019.html">u_avr32_scif_pll_t</a>   u_avr32_scif_pll;
<a name="l00367"></a>00367   
<a name="l00368"></a>00368     <span class="comment">// Read Register</span>
<a name="l00369"></a>00369     u_avr32_scif_pll.<a class="code" href="a00019.html#ae4b06442c68ab961ebd544fb12b7018e">PLL</a>[pll] = AVR32_SCIF.PLL[pll] ;
<a name="l00370"></a>00370     <span class="comment">// Modify Configuration </span>
<a name="l00371"></a>00371     u_avr32_scif_pll.<a class="code" href="a00019.html#ae4b06442c68ab961ebd544fb12b7018e">PLL</a>[pll].pllen = <a class="code" href="a00021.html#a514ad415fb6125ba296793df7d1a468a">ENABLE</a>;
<a name="l00372"></a>00372     <a class="code" href="a00050.html#ga6614d1866189f3f0c9a66e5c18e6a261" title="Start section with code protected against interrupts.">AVR32_ENTER_CRITICAL_REGION</a>( );
<a name="l00373"></a>00373     <span class="comment">// Unlock the write-protected PLL0 register</span>
<a name="l00374"></a>00374     <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_PLL + 4*pll); 
<a name="l00375"></a>00375     <span class="comment">// Write Back</span>
<a name="l00376"></a>00376     AVR32_SCIF.PLL[pll] = u_avr32_scif_pll.<a class="code" href="a00019.html#ae4b06442c68ab961ebd544fb12b7018e">PLL</a>[pll];
<a name="l00377"></a>00377     <a class="code" href="a00050.html#ga85b7f1705a7949f2e8dfacb071e00c6a" title="End section with code protected against interrupts.">AVR32_LEAVE_CRITICAL_REGION</a>( );
<a name="l00378"></a>00378   
<a name="l00379"></a>00379   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00380"></a>00380 }
<a name="l00381"></a>00381 
<a name="l00382"></a><a class="code" href="a00042.html#a9fe5c285353fbea44393e996d603d257">00382</a> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="a00041.html#a9fe5c285353fbea44393e996d603d257" title="This function will disable a PLL.">scif_pll_disable</a>(<a class="code" href="a00042.html#aee67e9247cde3191caf3a6ec8cc49131" title="The different plls.">scif_pll_t</a> pll)
<a name="l00383"></a>00383 {
<a name="l00384"></a>00384 
<a name="l00385"></a>00385   <a class="code" href="a00019.html">u_avr32_scif_pll_t</a>   u_avr32_scif_pll;
<a name="l00386"></a>00386 
<a name="l00387"></a>00387   <span class="comment">// Read Register</span>
<a name="l00388"></a>00388   u_avr32_scif_pll.<a class="code" href="a00019.html#ae4b06442c68ab961ebd544fb12b7018e">PLL</a>[pll] = AVR32_SCIF.PLL[pll] ;
<a name="l00389"></a>00389   <span class="comment">// Modify Configuration </span>
<a name="l00390"></a>00390   u_avr32_scif_pll.<a class="code" href="a00019.html#ae4b06442c68ab961ebd544fb12b7018e">PLL</a>[pll].pllen = <a class="code" href="a00021.html#a99496f7308834e8b220f7894efa0b6ab">DISABLE</a>;
<a name="l00391"></a>00391   <a class="code" href="a00050.html#ga6614d1866189f3f0c9a66e5c18e6a261" title="Start section with code protected against interrupts.">AVR32_ENTER_CRITICAL_REGION</a>( );
<a name="l00392"></a>00392   <span class="comment">// Unlock the write-protected PLL0 register</span>
<a name="l00393"></a>00393   <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_PLL + 4*pll); 
<a name="l00394"></a>00394   <span class="comment">// Write Back</span>
<a name="l00395"></a>00395   AVR32_SCIF.PLL[pll] = u_avr32_scif_pll.<a class="code" href="a00019.html#ae4b06442c68ab961ebd544fb12b7018e">PLL</a>[pll];
<a name="l00396"></a>00396   <a class="code" href="a00050.html#ga85b7f1705a7949f2e8dfacb071e00c6a" title="End section with code protected against interrupts.">AVR32_LEAVE_CRITICAL_REGION</a>( );
<a name="l00397"></a>00397 
<a name="l00398"></a>00398   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00399"></a>00399 }
<a name="l00400"></a>00400 
<a name="l00401"></a><a class="code" href="a00042.html#a8d9f1c5f02e409cac54b5e518eb6b717">00401</a> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="a00041.html#a8d9f1c5f02e409cac54b5e518eb6b717" title="This function will wait for PLL locked.">scif_wait_for_pll_locked</a>(<a class="code" href="a00042.html#aee67e9247cde3191caf3a6ec8cc49131" title="The different plls.">scif_pll_t</a> pll)
<a name="l00402"></a>00402 {
<a name="l00403"></a>00403   
<a name="l00404"></a>00404   <span class="keywordflow">if</span> (pll == <a class="code" href="a00042.html#aee67e9247cde3191caf3a6ec8cc49131afb73f3e6fe0f1649f6e70bb74f447536">SCIF_PLL0</a>)
<a name="l00405"></a>00405   { 
<a name="l00406"></a>00406       <span class="comment">// Wait until PLL0 is stable and ready to be used.</span>
<a name="l00407"></a>00407       <span class="keywordflow">while</span>(!(AVR32_SCIF.pclksr &amp; AVR32_SCIF_PCLKSR_PLL0_LOCK_MASK));
<a name="l00408"></a>00408   }
<a name="l00409"></a>00409   <span class="keywordflow">else</span>
<a name="l00410"></a>00410   {
<a name="l00411"></a>00411       <span class="comment">// Wait until PLL1 is stable and ready to be used.</span>
<a name="l00412"></a>00412       <span class="keywordflow">while</span>(!(AVR32_SCIF.pclksr &amp; AVR32_SCIF_PCLKSR_PLL1_LOCK_MASK));
<a name="l00413"></a>00413   }
<a name="l00414"></a>00414   
<a name="l00415"></a>00415   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00416"></a>00416 }
<a name="l00417"></a>00417  
<a name="l00422"></a><a class="code" href="a00042.html#a1a5d5f264ce6f288aa94fecbc8b24b10">00422</a> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="a00041.html#a1a5d5f264ce6f288aa94fecbc8b24b10" title="OSC32 Functions.">scif_start_osc32</a>(<span class="keyword">const</span> <a class="code" href="a00007.html" title="OSC32 startup options.">scif_osc32_opt_t</a> *opt, <span class="keywordtype">bool</span> wait_for_ready)
<a name="l00423"></a>00423 {
<a name="l00424"></a>00424   <a class="code" href="a00017.html">u_avr32_scif_oscctrl32_t</a>  u_avr32_scif_oscctrl32;
<a name="l00425"></a>00425   
<a name="l00426"></a>00426   
<a name="l00427"></a>00427 <span class="preprocessor">#ifdef AVR32SFW_INPUT_CHECK</span>
<a name="l00428"></a>00428 <span class="preprocessor"></span>  <span class="comment">// Check that the input frequency is in the supported frequency range.</span>
<a name="l00429"></a>00429   <span class="keywordflow">if</span>( (opt-&gt;<a class="code" href="a00007.html#a9e4a17285bc2cc6741ae58d5821dfb75" title="The input frequency (from the external clock or the crystal).">freq_hz</a> &lt; <a class="code" href="a00042.html#a6ec08d0cd02a6104e0f98f22b94d0fb4" title="Device-specific data.">SCIF_EXT_CRYSTAL_MIN_FREQ_HZ</a>)
<a name="l00430"></a>00430       || (opt-&gt;<a class="code" href="a00007.html#a9e4a17285bc2cc6741ae58d5821dfb75" title="The input frequency (from the external clock or the crystal).">freq_hz</a> &gt; <a class="code" href="a00042.html#a00368dbc88219075cb01d352b2725c82">SCIF_EXT_CRYSTAL_MAX_FREQ_HZ</a>))
<a name="l00431"></a>00431   {
<a name="l00432"></a>00432     <span class="keywordflow">return</span> -1;
<a name="l00433"></a>00433   }
<a name="l00434"></a>00434   <span class="comment">// Check : for OSC0/OSC1, only 2 modes are supported</span>
<a name="l00435"></a>00435   <span class="keywordflow">if</span>( (opt-&gt;<a class="code" href="a00007.html#a9c5abc962b1b136103403be646983e21" title="Set the oscillator mode.">mode</a> &lt; <a class="code" href="a00042.html#a9a708e94c5df197717f5859f6b8b257caab4ef315627644c27b21ace5afcc3aac">SCIF_OSC_MODE_EXT_CLK</a>)
<a name="l00436"></a>00436       || (opt-&gt;<a class="code" href="a00007.html#a9c5abc962b1b136103403be646983e21" title="Set the oscillator mode.">mode</a> &gt; <a class="code" href="a00042.html#a9a708e94c5df197717f5859f6b8b257ca3b93142664c5679290dcacf047360aae">SCIF_OSC_MODE_2PIN_CRYSTAL</a>)
<a name="l00437"></a>00437       || (opt-&gt;<a class="code" href="a00007.html#a9c5abc962b1b136103403be646983e21" title="Set the oscillator mode.">mode</a> == SCIF_OSC_MODE_NOT_SUPPORTED_1)
<a name="l00438"></a>00438       || (opt-&gt;<a class="code" href="a00007.html#a9c5abc962b1b136103403be646983e21" title="Set the oscillator mode.">mode</a> == SCIF_OSC_MODE_NOT_SUPPORTED_2) )
<a name="l00439"></a>00439   {
<a name="l00440"></a>00440     <span class="keywordflow">return</span> -1;
<a name="l00441"></a>00441   }
<a name="l00442"></a>00442   <span class="comment">// Check that the startup value is in the supported range.</span>
<a name="l00443"></a>00443   <span class="keywordflow">if</span>(opt-&gt;<a class="code" href="a00007.html#af5305417f3897eb2e3b178485e99238f" title="Specify the oscillator startup time.">startup</a> &gt; (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)AVR32_SCIF_OSCCTRL32_STARTUP_524288_RCOSC)
<a name="l00444"></a>00444   {
<a name="l00445"></a>00445     <span class="keywordflow">return</span> -1;
<a name="l00446"></a>00446   }
<a name="l00447"></a>00447 <span class="preprocessor">#endif  // AVR32SFW_INPUT_CHECK</span>
<a name="l00448"></a>00448 <span class="preprocessor"></span>
<a name="l00449"></a>00449   <span class="comment">// Read Register</span>
<a name="l00450"></a>00450   u_avr32_scif_oscctrl32.<a class="code" href="a00017.html#a29f7f13d957ead97f8a3e4707c676e98">oscctrl32</a> = AVR32_SCIF.oscctrl32 ;  
<a name="l00451"></a>00451   
<a name="l00452"></a>00452   <span class="comment">// Modify : Configure &amp; start OSC32.</span>
<a name="l00453"></a>00453   u_avr32_scif_oscctrl32.<a class="code" href="a00017.html#a9272a4e5c4da7e51c36d36dc497b9a7b">OSCCTRL32</a>.mode = opt-&gt;<a class="code" href="a00007.html#a9c5abc962b1b136103403be646983e21" title="Set the oscillator mode.">mode</a>;
<a name="l00454"></a>00454   u_avr32_scif_oscctrl32.<a class="code" href="a00017.html#a9272a4e5c4da7e51c36d36dc497b9a7b">OSCCTRL32</a>.startup = opt-&gt;<a class="code" href="a00007.html#af5305417f3897eb2e3b178485e99238f" title="Specify the oscillator startup time.">startup</a>;
<a name="l00455"></a>00455   u_avr32_scif_oscctrl32.<a class="code" href="a00017.html#a9272a4e5c4da7e51c36d36dc497b9a7b">OSCCTRL32</a>.osc32en = <a class="code" href="a00021.html#a514ad415fb6125ba296793df7d1a468a">ENABLE</a>;
<a name="l00456"></a>00456   
<a name="l00457"></a>00457   <a class="code" href="a00050.html#ga6614d1866189f3f0c9a66e5c18e6a261" title="Start section with code protected against interrupts.">AVR32_ENTER_CRITICAL_REGION</a>( );
<a name="l00458"></a>00458   <span class="comment">// Unlock the write-protected OSCCTRL32 register</span>
<a name="l00459"></a>00459   <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_OSCCTRL32);
<a name="l00460"></a>00460   
<a name="l00461"></a>00461   <span class="comment">// Write Back</span>
<a name="l00462"></a>00462   AVR32_SCIF.oscctrl32 = u_avr32_scif_oscctrl32.<a class="code" href="a00017.html#a29f7f13d957ead97f8a3e4707c676e98">oscctrl32</a>;
<a name="l00463"></a>00463   <a class="code" href="a00050.html#ga85b7f1705a7949f2e8dfacb071e00c6a" title="End section with code protected against interrupts.">AVR32_LEAVE_CRITICAL_REGION</a>( );
<a name="l00464"></a>00464 
<a name="l00465"></a>00465   <span class="keywordflow">if</span>(<span class="keyword">true</span> == wait_for_ready)
<a name="l00466"></a>00466   {
<a name="l00467"></a>00467     <span class="comment">// Wait until OSC32 is stable and ready to be used.</span>
<a name="l00468"></a>00468     <span class="keywordflow">if</span>(<a class="code" href="a00041.html#a5f0069245d4d5cbfea5cb6b3300a6c0b" title="Wait for a status high in the Power and Clocks status register.">scif_pclksr_statushigh_wait</a>(AVR32_SCIF_PCLKSR_OSC32RDY_MASK))
<a name="l00469"></a>00469       <span class="keywordflow">return</span> -1;
<a name="l00470"></a>00470   }
<a name="l00471"></a>00471   
<a name="l00472"></a>00472   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00473"></a>00473 }
<a name="l00474"></a>00474 
<a name="l00475"></a>00475 
<a name="l00476"></a><a class="code" href="a00042.html#acc245a2bbf963e3d223881edde52e9a0">00476</a> <span class="keywordtype">long</span> <a class="code" href="a00041.html#aacf9a41e2edc362e9dd0e90fe544cd14" title="Stop the OSC32 oscillator.">scif_stop_osc32</a>()
<a name="l00477"></a>00477 {
<a name="l00478"></a>00478   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> temp = AVR32_SCIF.oscctrl32;
<a name="l00479"></a>00479   temp &amp;= ~(AVR32_SCIF_OSCCTRL32_OSC32EN_DISABLE &lt;&lt; AVR32_SCIF_OSCCTRL32_OSC32EN_OFFSET);
<a name="l00480"></a>00480 
<a name="l00481"></a>00481   <a class="code" href="a00050.html#ga6614d1866189f3f0c9a66e5c18e6a261" title="Start section with code protected against interrupts.">AVR32_ENTER_CRITICAL_REGION</a>( );
<a name="l00482"></a>00482   <span class="comment">// Unlock the write-protected OSCCTRL32 register</span>
<a name="l00483"></a>00483   <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_OSCCTRL32);
<a name="l00484"></a>00484   
<a name="l00485"></a>00485   <span class="comment">// Stop OSC32.</span>
<a name="l00486"></a>00486   AVR32_SCIF.oscctrl32 = temp;
<a name="l00487"></a>00487   <a class="code" href="a00050.html#ga85b7f1705a7949f2e8dfacb071e00c6a" title="End section with code protected against interrupts.">AVR32_LEAVE_CRITICAL_REGION</a>( );
<a name="l00488"></a>00488 
<a name="l00489"></a>00489   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00490"></a>00490 }
<a name="l00491"></a>00491 
<a name="l00492"></a>00492 
<a name="l00506"></a><a class="code" href="a00042.html#a98d84a449826183d517302ad4bb6a013">00506</a> <span class="keywordtype">void</span> <a class="code" href="a00041.html#a98d84a449826183d517302ad4bb6a013" title="Calibration Functions.">scif_start_rc8M</a>(<span class="keywordtype">void</span>)
<a name="l00507"></a>00507 {
<a name="l00508"></a>00508   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* calibration_bits = (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>*)0x80800200;
<a name="l00509"></a>00509   <a class="code" href="a00050.html#ga6614d1866189f3f0c9a66e5c18e6a261" title="Start section with code protected against interrupts.">AVR32_ENTER_CRITICAL_REGION</a>( );
<a name="l00510"></a>00510   <span class="comment">// Unlock the write-protected RC8MCR register</span>
<a name="l00511"></a>00511   <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_RCCR8);
<a name="l00512"></a>00512   AVR32_SCIF.rccr8 = AVR32_SCIF_RCCR8_RCOSC8_EN_MASK | ((*calibration_bits)&amp;AVR32_SCIF_RCCR8_CALIB_MASK);
<a name="l00513"></a>00513   <a class="code" href="a00050.html#ga85b7f1705a7949f2e8dfacb071e00c6a" title="End section with code protected against interrupts.">AVR32_LEAVE_CRITICAL_REGION</a>( );
<a name="l00514"></a>00514 }
<a name="l00515"></a>00515 
<a name="l00516"></a><a class="code" href="a00042.html#ab2638cbe755096f6c9782a4248bef530">00516</a> <span class="keywordtype">void</span> <a class="code" href="a00041.html#ab2638cbe755096f6c9782a4248bef530" title="Stop the 8MHz internal RCosc (RC8M) clock.">scif_stop_rc8M</a>(<span class="keywordtype">void</span>)
<a name="l00517"></a>00517 {
<a name="l00518"></a>00518   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> temp = AVR32_SCIF.rccr8;
<a name="l00519"></a>00519   
<a name="l00520"></a>00520   <a class="code" href="a00050.html#ga6614d1866189f3f0c9a66e5c18e6a261" title="Start section with code protected against interrupts.">AVR32_ENTER_CRITICAL_REGION</a>( );
<a name="l00521"></a>00521   <span class="comment">// Unlock the write-protected RC8MCR register</span>
<a name="l00522"></a>00522   <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_RCCR8);
<a name="l00523"></a>00523   temp &amp;= ~AVR32_SCIF_RCCR8_RCOSC8_EN_MASK;
<a name="l00524"></a>00524   AVR32_SCIF.rccr8 = temp;
<a name="l00525"></a>00525   <a class="code" href="a00050.html#ga85b7f1705a7949f2e8dfacb071e00c6a" title="End section with code protected against interrupts.">AVR32_LEAVE_CRITICAL_REGION</a>( );
<a name="l00526"></a>00526 }
<a name="l00527"></a>00527 
<a name="l00532"></a><a class="code" href="a00042.html#a059e71c82dac925ae59dc36cdbf30222">00532</a> <span class="keywordtype">void</span> <a class="code" href="a00041.html#a059e71c82dac925ae59dc36cdbf30222" title="120MHz RCosc Functions">scif_start_rc120M</a>(<span class="keywordtype">void</span>)
<a name="l00533"></a>00533 {
<a name="l00534"></a>00534   <a class="code" href="a00050.html#ga6614d1866189f3f0c9a66e5c18e6a261" title="Start section with code protected against interrupts.">AVR32_ENTER_CRITICAL_REGION</a>( );
<a name="l00535"></a>00535   <span class="comment">// Unlock the write-protected RC120MCR register</span>
<a name="l00536"></a>00536   <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_RC120MCR);
<a name="l00537"></a>00537   AVR32_SCIF.rc120mcr = AVR32_SCIF_RC120MCR_EN_MASK;
<a name="l00538"></a>00538   <a class="code" href="a00050.html#ga85b7f1705a7949f2e8dfacb071e00c6a" title="End section with code protected against interrupts.">AVR32_LEAVE_CRITICAL_REGION</a>( );
<a name="l00539"></a>00539 }
<a name="l00540"></a>00540 
<a name="l00541"></a><a class="code" href="a00042.html#a371afeca81ee2c2158e2c210f15440f9">00541</a> <span class="keywordtype">void</span> <a class="code" href="a00041.html#a371afeca81ee2c2158e2c210f15440f9" title="Stop the 120MHz internal RCosc (RC120M) clock.">scif_stop_rc120M</a>(<span class="keywordtype">void</span>)
<a name="l00542"></a>00542 {
<a name="l00543"></a>00543   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> temp = AVR32_SCIF.rc120mcr;
<a name="l00544"></a>00544 
<a name="l00545"></a>00545   <a class="code" href="a00050.html#ga6614d1866189f3f0c9a66e5c18e6a261" title="Start section with code protected against interrupts.">AVR32_ENTER_CRITICAL_REGION</a>( );
<a name="l00546"></a>00546   <span class="comment">// Unlock the write-protected RC120MCR register</span>
<a name="l00547"></a>00547   <a class="code" href="a00042.html#af06c6a1ecbab9e8c283124c594846dea" title="Unlock SCIF register macro.">SCIF_UNLOCK</a>(AVR32_SCIF_RC120MCR);
<a name="l00548"></a>00548   temp &amp;= ~AVR32_SCIF_RC120MCR_EN_MASK;
<a name="l00549"></a>00549   AVR32_SCIF.rc120mcr = temp;
<a name="l00550"></a>00550   <a class="code" href="a00050.html#ga85b7f1705a7949f2e8dfacb071e00c6a" title="End section with code protected against interrupts.">AVR32_LEAVE_CRITICAL_REGION</a>( );
<a name="l00551"></a>00551 }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 
<a name="l00559"></a><a class="code" href="a00042.html#a966f2ea463bfc21d1fbc8f5bd62365dd">00559</a> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="a00041.html#a966f2ea463bfc21d1fbc8f5bd62365dd" title="Generic Clock Functions.">scif_start_gclk</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gclk, <span class="keyword">const</span> <a class="code" href="a00006.html" title="Generic clock generation settings.">scif_gclk_opt_t</a> *opt)
<a name="l00560"></a>00560 {
<a name="l00561"></a>00561 <span class="preprocessor">#ifdef AVR32SFW_INPUT_CHECK</span>
<a name="l00562"></a>00562 <span class="preprocessor"></span>  <span class="comment">// Check that the generic clock number is correct</span>
<a name="l00563"></a>00563   <span class="keywordflow">if</span>( gclk &gt; AVR32_SCIF_GCLK_NUM )
<a name="l00564"></a>00564   {
<a name="l00565"></a>00565     <span class="keywordflow">return</span> -1;
<a name="l00566"></a>00566   }
<a name="l00567"></a>00567   <span class="comment">// Check that the clock source for the generic clock is correct.</span>
<a name="l00568"></a>00568   <span class="keywordflow">if</span>(( opt-&gt;<a class="code" href="a00006.html#a7f093e4c255de54d9ab438356372fdf1" title="The input clock source to use for the generic clock.">clock_source</a> &gt;= <a class="code" href="a00042.html#a2a2e11f06784f5133dd912e595fde6f0a6c6ccb2e6b36df23583746f07f23c7c4">SCIF_GCCTRL_OSCSEL_INVALID</a> ) || ( opt-&gt;<a class="code" href="a00006.html#a7f093e4c255de54d9ab438356372fdf1" title="The input clock source to use for the generic clock.">clock_source</a> &lt; 0 ))
<a name="l00569"></a>00569   {
<a name="l00570"></a>00570     <span class="keywordflow">return</span> -1;
<a name="l00571"></a>00571   }
<a name="l00572"></a>00572 <span class="preprocessor">#endif  // AVR32SFW_INPUT_CHECK</span>
<a name="l00573"></a>00573 <span class="preprocessor"></span>
<a name="l00574"></a>00574   <span class="comment">// If the generic clock is already enabled, return an error.</span>
<a name="l00575"></a>00575   <span class="keywordflow">if</span>(AVR32_SCIF.gcctrl[gclk] &amp; AVR32_SCIF_GCCTRL_CEN_MASK)
<a name="l00576"></a>00576     <span class="keywordflow">return</span> -1;
<a name="l00577"></a>00577 
<a name="l00578"></a>00578   <span class="comment">// Configure &amp; start the generic clock.</span>
<a name="l00579"></a>00579   AVR32_SCIF.gcctrl[gclk] = ((opt-&gt;<a class="code" href="a00006.html#ab737b01b420ea1a5df2fb2de4efe6b3e" title="The division factor to apply to the clock src.">divider</a> &lt;&lt; AVR32_SCIF_GCCTRL_DIV_OFFSET)&amp;AVR32_SCIF_GCCTRL_DIV_MASK)
<a name="l00580"></a>00580                             |((opt-&gt;<a class="code" href="a00006.html#a9f55e1a053f9b01014ba215e52e1f2d8" title="Enable/disable the generic clock divisor.">diven</a> &lt;&lt; AVR32_SCIF_GCCTRL_DIVEN_OFFSET)&amp;AVR32_SCIF_GCCTRL_DIVEN_MASK)
<a name="l00581"></a>00581                             |((opt-&gt;<a class="code" href="a00006.html#a7f093e4c255de54d9ab438356372fdf1" title="The input clock source to use for the generic clock.">clock_source</a> &lt;&lt; AVR32_SCIF_GCCTRL_OSCSEL_OFFSET)&amp;AVR32_SCIF_GCCTRL_OSCSEL_MASK)
<a name="l00582"></a>00582                             |(AVR32_SCIF_GCCTRL_CEN_MASK);
<a name="l00583"></a>00583 
<a name="l00584"></a>00584   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00585"></a>00585 }
<a name="l00586"></a>00586 
<a name="l00587"></a>00587 
<a name="l00588"></a><a class="code" href="a00042.html#a703046a65be951d33d8907ca284d963a">00588</a> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="a00041.html#a703046a65be951d33d8907ca284d963a" title="Stop a generic clock.">scif_stop_gclk</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gclk)
<a name="l00589"></a>00589 {
<a name="l00590"></a>00590   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  timeout = <a class="code" href="a00042.html#a8758fcbbde760fe3498dd00acf238407" title="The timeguard used for polling in ticks.">SCIF_POLL_TIMEOUT</a>;
<a name="l00591"></a>00591   
<a name="l00592"></a>00592 <span class="preprocessor">#ifdef AVR32SFW_INPUT_CHECK</span>
<a name="l00593"></a>00593 <span class="preprocessor"></span>  <span class="comment">// Check that the generic clock number is correct</span>
<a name="l00594"></a>00594   <span class="keywordflow">if</span>( gclk &gt; AVR32_SCIF_GCLK_NUM )
<a name="l00595"></a>00595   {
<a name="l00596"></a>00596     <span class="keywordflow">return</span> -1;
<a name="l00597"></a>00597   }
<a name="l00598"></a>00598 <span class="preprocessor">#endif  // AVR32SFW_INPUT_CHECK</span>
<a name="l00599"></a>00599 <span class="preprocessor"></span>
<a name="l00600"></a>00600   <span class="comment">// Stop the generic clock.</span>
<a name="l00601"></a>00601   AVR32_SCIF.gcctrl[gclk] &amp;= ~AVR32_SCIF_GCCTRL_CEN_MASK;
<a name="l00602"></a>00602   
<a name="l00603"></a>00603   <span class="comment">// Wait until the generic clock is actually stopped.</span>
<a name="l00604"></a>00604   <span class="keywordflow">while</span>(AVR32_SCIF.gcctrl[gclk] &amp; AVR32_SCIF_GCCTRL_CEN_MASK)
<a name="l00605"></a>00605   {
<a name="l00606"></a>00606     <span class="keywordflow">if</span>(--timeout == 0)
<a name="l00607"></a>00607       <span class="keywordflow">return</span> -1;
<a name="l00608"></a>00608   }
<a name="l00609"></a>00609   
<a name="l00610"></a>00610   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00611"></a>00611 }
<a name="l00612"></a>00612 
<a name="l00613"></a>00613 
<a name="l00614"></a><a class="code" href="a00042.html#ac355443257f05c78943fdd41d8b8fb90">00614</a> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="a00041.html#ac355443257f05c78943fdd41d8b8fb90" title="Setup a generic clock.">scif_gc_setup</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gclk, <a class="code" href="a00042.html#a2a2e11f06784f5133dd912e595fde6f0" title="The different clock source for the generic clocks.">scif_gcctrl_oscsel_t</a> clk_src, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> diven, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> divfactor)
<a name="l00615"></a>00615 {
<a name="l00616"></a>00616   <span class="keywordtype">int</span> restart_gc = <span class="keyword">false</span>;
<a name="l00617"></a>00617   
<a name="l00618"></a>00618   
<a name="l00619"></a>00619   <span class="comment">// Change the division factor to conform to the equation: fgclk = fsrc/divfactor = fsrc/(2*(div+1))</span>
<a name="l00620"></a>00620   divfactor = (divfactor&gt;&gt;1) -1;
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 <span class="preprocessor">#ifdef AVR32SFW_INPUT_CHECK</span>
<a name="l00623"></a>00623 <span class="preprocessor"></span>  <span class="comment">// Check that the generic clock number is correct</span>
<a name="l00624"></a>00624   <span class="keywordflow">if</span>( gclk &gt; AVR32_SCIF_GCLK_NUM )
<a name="l00625"></a>00625   {
<a name="l00626"></a>00626     <span class="keywordflow">return</span> -1;
<a name="l00627"></a>00627   }
<a name="l00628"></a>00628   <span class="comment">// Check that the clock source for the generic clock is correct.</span>
<a name="l00629"></a>00629   <span class="keywordflow">if</span>(( clk_src &gt;= <a class="code" href="a00042.html#a2a2e11f06784f5133dd912e595fde6f0a6c6ccb2e6b36df23583746f07f23c7c4">SCIF_GCCTRL_OSCSEL_INVALID</a> ) || ( clk_src &lt; 0 ))
<a name="l00630"></a>00630   {
<a name="l00631"></a>00631     <span class="keywordflow">return</span> -1;
<a name="l00632"></a>00632   }
<a name="l00633"></a>00633   <span class="comment">// Check that the required division factor is correct.</span>
<a name="l00634"></a>00634   <span class="keywordflow">if</span>(diven)
<a name="l00635"></a>00635   {
<a name="l00636"></a>00636     <span class="keywordflow">if</span>(divfactor &gt;= (1&lt;&lt;AVR32_SCIF_GCCTRL_DIV_SIZE))
<a name="l00637"></a>00637       <span class="keywordflow">return</span> -1;
<a name="l00638"></a>00638   }
<a name="l00639"></a>00639 <span class="preprocessor">#endif  // AVR32SFW_INPUT_CHECK</span>
<a name="l00640"></a>00640 <span class="preprocessor"></span>
<a name="l00641"></a>00641   <span class="comment">// If the generic clock is already enabled, disable it before changing its setup.</span>
<a name="l00642"></a>00642   <span class="keywordflow">if</span>(AVR32_SCIF.gcctrl[gclk] &amp; AVR32_SCIF_GCCTRL_CEN_MASK)
<a name="l00643"></a>00643   {
<a name="l00644"></a>00644     restart_gc = <span class="keyword">true</span>;
<a name="l00645"></a>00645     <span class="keywordflow">if</span>(<a class="code" href="a00041.html#a703046a65be951d33d8907ca284d963a" title="Stop a generic clock.">scif_stop_gclk</a>(gclk) &lt; 0)
<a name="l00646"></a>00646       <span class="keywordflow">return</span> -1;  <span class="comment">// Could not stop the generic clock.</span>
<a name="l00647"></a>00647   }
<a name="l00648"></a>00648 
<a name="l00649"></a>00649   <span class="comment">// Setup the generic clock.</span>
<a name="l00650"></a>00650   AVR32_SCIF.gcctrl[gclk] = ((divfactor &lt;&lt; AVR32_SCIF_GCCTRL_DIV_OFFSET)&amp;AVR32_SCIF_GCCTRL_DIV_MASK)
<a name="l00651"></a>00651                             |((diven &lt;&lt; AVR32_SCIF_GCCTRL_DIVEN_OFFSET)&amp;AVR32_SCIF_GCCTRL_DIVEN_MASK)
<a name="l00652"></a>00652                             |((clk_src &lt;&lt; AVR32_SCIF_GCCTRL_OSCSEL_OFFSET)&amp;AVR32_SCIF_GCCTRL_OSCSEL_MASK);
<a name="l00653"></a>00653                             
<a name="l00654"></a>00654   <span class="comment">// Restart the gc if it previously was enabled.</span>
<a name="l00655"></a>00655   <span class="keywordflow">if</span>(<span class="keyword">true</span> == restart_gc)
<a name="l00656"></a>00656     AVR32_SCIF.gcctrl[gclk] |= AVR32_SCIF_GCCTRL_CEN_MASK ;
<a name="l00657"></a>00657 
<a name="l00658"></a>00658   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00659"></a>00659 }
<a name="l00660"></a>00660 
<a name="l00661"></a>00661 
<a name="l00662"></a><a class="code" href="a00042.html#a97cca4b2eb1d71d681f7b81f54e672c3">00662</a> <span class="keywordtype">long</span> <span class="keywordtype">int</span> <a class="code" href="a00041.html#a97cca4b2eb1d71d681f7b81f54e672c3" title="Enable a generic clock.">scif_gc_enable</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> gclk)
<a name="l00663"></a>00663 {
<a name="l00664"></a>00664 <span class="preprocessor">#ifdef AVR32SFW_INPUT_CHECK</span>
<a name="l00665"></a>00665 <span class="preprocessor"></span>  <span class="comment">// Check that the generic clock number is correct</span>
<a name="l00666"></a>00666   <span class="keywordflow">if</span>( gclk &gt; AVR32_SCIF_GCLK_NUM )
<a name="l00667"></a>00667   {
<a name="l00668"></a>00668     <span class="keywordflow">return</span> -1;
<a name="l00669"></a>00669   }
<a name="l00670"></a>00670 <span class="preprocessor">#endif  // AVR32SFW_INPUT_CHECK</span>
<a name="l00671"></a>00671 <span class="preprocessor"></span>
<a name="l00672"></a>00672   <span class="comment">// If the generic clock is already enabled, do nothing.</span>
<a name="l00673"></a>00673   <span class="keywordflow">if</span>(!(AVR32_SCIF.gcctrl[gclk] &amp; AVR32_SCIF_GCCTRL_CEN_MASK))
<a name="l00674"></a>00674     AVR32_SCIF.gcctrl[gclk] |= AVR32_SCIF_GCCTRL_CEN_MASK;
<a name="l00675"></a>00675     
<a name="l00676"></a>00676   <span class="keywordflow">return</span> <a class="code" href="a00021.html#aba5c54fadff8d880b1945dde87496e31">PASS</a>;
<a name="l00677"></a>00677 
<a name="l00678"></a>00678 }
<a name="l00679"></a>00679 
<a name="l00680"></a><a class="code" href="a00042.html#a180ec409dbfab40b802e883e43e7edba">00680</a> <span class="keywordtype">void</span> <a class="code" href="a00041.html#a180ec409dbfab40b802e883e43e7edba" title="Enables the 1.8V Brown-Out Detector interrupt.">scif_bod18_enable_irq</a>(<span class="keywordtype">void</span>)
<a name="l00681"></a>00681 {
<a name="l00682"></a>00682   AVR32_SCIF.ier = AVR32_SCIF_IER_BODDET_MASK ;
<a name="l00683"></a>00683 }
<a name="l00684"></a>00684 
<a name="l00685"></a><a class="code" href="a00042.html#a6855400b530bc304abe596e2aa6b7bc8">00685</a> <span class="keywordtype">void</span> <a class="code" href="a00041.html#a6855400b530bc304abe596e2aa6b7bc8" title="Disables the 1.8V Brown-Out Detector interrupt.">scif_bod18_disable_irq</a>(<span class="keywordtype">void</span>)
<a name="l00686"></a>00686 {
<a name="l00687"></a>00687   Bool global_interrupt_enabled = <a class="code" href="a00050.html#gab7b13c60d26b190e73e540586f1868f8">Is_global_interrupt_enabled</a>();
<a name="l00688"></a>00688 
<a name="l00689"></a>00689   <span class="keywordflow">if</span> (global_interrupt_enabled) <a class="code" href="a00050.html#ga4834270e1b8984fe025bce15e7ae1564">Disable_global_interrupt</a>();
<a name="l00690"></a>00690   AVR32_SCIF.idr = AVR32_SCIF_IDR_BODDET_MASK;
<a name="l00691"></a>00691   AVR32_SCIF.isr;
<a name="l00692"></a>00692   <span class="keywordflow">if</span> (global_interrupt_enabled) <a class="code" href="a00050.html#gaebdc47e7800e11d79b9e5e2da1fecaa6">Enable_global_interrupt</a>();
<a name="l00693"></a>00693 }
<a name="l00694"></a>00694 
<a name="l00695"></a><a class="code" href="a00042.html#a32c4bf1084e3462837559441eb4f2455">00695</a> <span class="keywordtype">void</span> <a class="code" href="a00041.html#a32c4bf1084e3462837559441eb4f2455" title="Clears the 1.8V Brown-Out Detector interrupt flag.">scif_bod18_clear_irq</a>(<span class="keywordtype">void</span>)
<a name="l00696"></a>00696 {
<a name="l00697"></a>00697   AVR32_SCIF.icr = AVR32_SCIF_ICR_BODDET_MASK;
<a name="l00698"></a>00698 }
<a name="l00699"></a>00699 
<a name="l00700"></a><a class="code" href="a00042.html#ad518d8685614797a31c212e961d8725f">00700</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00041.html#ad518d8685614797a31c212e961d8725f" title="Gets the 1.8V Brown-Out Detector interrupt flag.">scif_bod18_get_irq_status</a>(<span class="keywordtype">void</span>)
<a name="l00701"></a>00701 {
<a name="l00702"></a>00702   <span class="keywordflow">return</span> ((AVR32_SCIF.isr &amp; AVR32_SCIF_ISR_BODDET_MASK) != 0);
<a name="l00703"></a>00703 }
<a name="l00704"></a>00704 
<a name="l00705"></a><a class="code" href="a00042.html#aa9b3ed37bade8509a107e86916e18805">00705</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00041.html#aa9b3ed37bade8509a107e86916e18805" title="Gets the 1.8V Brown-Out Detector interrupt enable status.">scif_bod18_get_irq_enable_bit</a>(<span class="keywordtype">void</span>)
<a name="l00706"></a>00706 {
<a name="l00707"></a>00707   <span class="keywordflow">return</span> ((AVR32_SCIF.imr &amp; AVR32_SCIF_IMR_BODDET_MASK) != 0);
<a name="l00708"></a>00708 }
<a name="l00709"></a>00709 
<a name="l00710"></a><a class="code" href="a00042.html#ab9def9f54fbc0861e37b52f7ccd00d06">00710</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00041.html#ab9def9f54fbc0861e37b52f7ccd00d06" title="Gets the triggering threshold of the 1.8V Brown-Out Detector.">scif_bod18_get_level</a>(<span class="keywordtype">void</span>)
<a name="l00711"></a>00711 {
<a name="l00712"></a>00712   <span class="keywordflow">return</span> (AVR32_SCIF.bod &amp; AVR32_SCIF_BOD_LEVEL_MASK) &gt;&gt; AVR32_SCIF_BOD_LEVEL_OFFSET;
<a name="l00713"></a>00713 }
<a name="l00714"></a>00714 
<a name="l00715"></a><a class="code" href="a00042.html#a41885a5f7da5d63fd6e6ed8e58608fe7">00715</a> <span class="keywordtype">void</span> <a class="code" href="a00041.html#a41885a5f7da5d63fd6e6ed8e58608fe7" title="Enables the 3.3V Brown-Out Detector interrupt.">scif_bod33_enable_irq</a>(<span class="keywordtype">void</span>)
<a name="l00716"></a>00716 {
<a name="l00717"></a>00717   AVR32_SCIF.ier = AVR32_SCIF_IER_BOD33DET_MASK ;
<a name="l00718"></a>00718 }
<a name="l00719"></a>00719 
<a name="l00720"></a><a class="code" href="a00042.html#a41673b52a3fc9749f9ff34a3faa977ef">00720</a> <span class="keywordtype">void</span> <a class="code" href="a00041.html#a41673b52a3fc9749f9ff34a3faa977ef" title="Disables the 3.3V Brown-Out Detector interrupt.">scif_bod33_disable_irq</a>(<span class="keywordtype">void</span>)
<a name="l00721"></a>00721 {
<a name="l00722"></a>00722    Bool global_interrupt_enabled = <a class="code" href="a00050.html#gab7b13c60d26b190e73e540586f1868f8">Is_global_interrupt_enabled</a>();
<a name="l00723"></a>00723 
<a name="l00724"></a>00724   <span class="keywordflow">if</span> (global_interrupt_enabled) <a class="code" href="a00050.html#ga4834270e1b8984fe025bce15e7ae1564">Disable_global_interrupt</a>();
<a name="l00725"></a>00725   AVR32_SCIF.idr = AVR32_SCIF_IDR_BOD33DET_MASK;
<a name="l00726"></a>00726   AVR32_SCIF.isr;
<a name="l00727"></a>00727   <span class="keywordflow">if</span> (global_interrupt_enabled) <a class="code" href="a00050.html#gaebdc47e7800e11d79b9e5e2da1fecaa6">Enable_global_interrupt</a>();
<a name="l00728"></a>00728 }
<a name="l00729"></a>00729  
<a name="l00730"></a><a class="code" href="a00042.html#a72c758d2924ea2814d4bcfe1c122022f">00730</a> <span class="keywordtype">void</span> <a class="code" href="a00041.html#a72c758d2924ea2814d4bcfe1c122022f" title="Clears the 3.3V Brown-Out Detector interrupt flag.">scif_bod33_clear_irq</a>(<span class="keywordtype">void</span>)
<a name="l00731"></a>00731 {
<a name="l00732"></a>00732   AVR32_SCIF.icr = AVR32_SCIF_ICR_BOD33DET_MASK;
<a name="l00733"></a>00733 }
<a name="l00734"></a>00734  
<a name="l00735"></a><a class="code" href="a00042.html#a651f36eaffe08306358f55b5f1880332">00735</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00041.html#a651f36eaffe08306358f55b5f1880332" title="Gets the 3.3V Brown-Out Detector interrupt flag.">scif_bod33_get_irq_status</a>(<span class="keywordtype">void</span>)
<a name="l00736"></a>00736 {
<a name="l00737"></a>00737   <span class="keywordflow">return</span> ((AVR32_SCIF.isr &amp; AVR32_SCIF_ISR_BOD33DET_MASK) != 0);
<a name="l00738"></a>00738 }
<a name="l00739"></a>00739  
<a name="l00740"></a><a class="code" href="a00042.html#a35f2e5cca380e07e793b74f43cfd6149">00740</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00041.html#a35f2e5cca380e07e793b74f43cfd6149" title="Gets the 3.3V Brown-Out Detector interrupt enable status.">scif_bod33_get_irq_enable_bit</a>(<span class="keywordtype">void</span>)
<a name="l00741"></a>00741 {
<a name="l00742"></a>00742   <span class="keywordflow">return</span> ((AVR32_SCIF.imr &amp; AVR32_SCIF_IMR_BOD33DET_MASK) != 0);
<a name="l00743"></a>00743 }
<a name="l00744"></a>00744  
<a name="l00745"></a><a class="code" href="a00042.html#ab9960fafcbb182162fd5c1605b0c9b7b">00745</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00041.html#ab9960fafcbb182162fd5c1605b0c9b7b" title="Gets the triggering threshold of the 3.3V Brown-Out Detector.">scif_bod33_get_level</a>(<span class="keywordtype">void</span>)
<a name="l00746"></a>00746 {
<a name="l00747"></a>00747   <span class="keywordflow">return</span> (AVR32_SCIF.bod33 &amp; AVR32_SCIF_BOD33_LEVEL_MASK) &gt;&gt; AVR32_SCIF_BOD33_LEVEL_OFFSET;
<a name="l00748"></a>00748 }
<a name="l00749"></a>00749 
<a name="l00750"></a><a class="code" href="a00042.html#a2bb02cf9fc20b9e72ba0582727e0fcba">00750</a> <span class="keywordtype">void</span> <a class="code" href="a00041.html#a2bb02cf9fc20b9e72ba0582727e0fcba" title="Enables the 5.0V Brown-Out Detector interrupt.">scif_bod50_enable_irq</a>(<span class="keywordtype">void</span>)
<a name="l00751"></a>00751 {
<a name="l00752"></a>00752   AVR32_SCIF.ier = AVR32_SCIF_IER_BOD50DET_MASK ;
<a name="l00753"></a>00753 }
<a name="l00754"></a>00754 
<a name="l00755"></a><a class="code" href="a00042.html#a4ebccdb22b97237b7a435403e7464969">00755</a> <span class="keywordtype">void</span> <a class="code" href="a00041.html#a4ebccdb22b97237b7a435403e7464969" title="Disables the 5.0V Brown-Out Detector interrupt.">scif_bod50_disable_irq</a>(<span class="keywordtype">void</span>)
<a name="l00756"></a>00756 {
<a name="l00757"></a>00757    Bool global_interrupt_enabled = <a class="code" href="a00050.html#gab7b13c60d26b190e73e540586f1868f8">Is_global_interrupt_enabled</a>();
<a name="l00758"></a>00758 
<a name="l00759"></a>00759   <span class="keywordflow">if</span> (global_interrupt_enabled) <a class="code" href="a00050.html#ga4834270e1b8984fe025bce15e7ae1564">Disable_global_interrupt</a>();
<a name="l00760"></a>00760   AVR32_SCIF.idr = AVR32_SCIF_IDR_BOD50DET_MASK;
<a name="l00761"></a>00761   AVR32_SCIF.isr;
<a name="l00762"></a>00762   <span class="keywordflow">if</span> (global_interrupt_enabled) <a class="code" href="a00050.html#gaebdc47e7800e11d79b9e5e2da1fecaa6">Enable_global_interrupt</a>();
<a name="l00763"></a>00763 }
<a name="l00764"></a>00764  
<a name="l00765"></a><a class="code" href="a00042.html#a06a5914736539eec3f64773c3ab46244">00765</a> <span class="keywordtype">void</span> <a class="code" href="a00041.html#a06a5914736539eec3f64773c3ab46244" title="Clears the 5.0V Brown-Out Detector interrupt flag.">scif_bod50_clear_irq</a>(<span class="keywordtype">void</span>)
<a name="l00766"></a>00766 {
<a name="l00767"></a>00767   AVR32_SCIF.icr = AVR32_SCIF_ICR_BOD50DET_MASK;
<a name="l00768"></a>00768 }
<a name="l00769"></a>00769  
<a name="l00770"></a><a class="code" href="a00042.html#adadb46f98e9bdc8a8b8adbab790d4527">00770</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00041.html#adadb46f98e9bdc8a8b8adbab790d4527" title="Gets the 5.0V Brown-Out Detector interrupt flag.">scif_bod50_get_irq_status</a>(<span class="keywordtype">void</span>)
<a name="l00771"></a>00771 {
<a name="l00772"></a>00772   <span class="keywordflow">return</span> ((AVR32_SCIF.isr &amp; AVR32_SCIF_ISR_BOD50DET_MASK) != 0);
<a name="l00773"></a>00773 }
<a name="l00774"></a>00774  
<a name="l00775"></a><a class="code" href="a00042.html#a9b98a43164cc8adce3ac426aa16324d5">00775</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00041.html#a9b98a43164cc8adce3ac426aa16324d5" title="Gets the 5.0V Brown-Out Detector interrupt enable status.">scif_bod50_get_irq_enable_bit</a>(<span class="keywordtype">void</span>)
<a name="l00776"></a>00776 {
<a name="l00777"></a>00777   <span class="keywordflow">return</span> ((AVR32_SCIF.imr &amp; AVR32_SCIF_IMR_BOD50DET_MASK) != 0);
<a name="l00778"></a>00778 }
<a name="l00779"></a>00779  
<a name="l00780"></a><a class="code" href="a00042.html#a06d74e1911e65c5549e6251b9da57f81">00780</a> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <a class="code" href="a00041.html#a06d74e1911e65c5549e6251b9da57f81" title="Gets the triggering threshold of the 5.0V Brown-Out Detector.">scif_bod50_get_level</a>(<span class="keywordtype">void</span>)
<a name="l00781"></a>00781 {
<a name="l00782"></a>00782   <span class="keywordflow">return</span> (AVR32_SCIF.bod50 &amp; AVR32_SCIF_BOD50_LEVEL_MASK) &gt;&gt; AVR32_SCIF_BOD50_LEVEL_OFFSET;
<a name="l00783"></a>00783 }
<a name="l00784"></a>00784 
</pre></div></div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Nov 15 14:11:30 2010 for PWM4 Example for uc3c_ek by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
